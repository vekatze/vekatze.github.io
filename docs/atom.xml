<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>以析比域</title>
    <link href="https://vekatze.github.io/atom.xml" rel="self" />
    <link href="https://vekatze.github.io" />
    <id>https://vekatze.github.io/atom.xml</id>
    <author>
        <name>vekatze</name>
        <email>vekatze@icloud.com</email>
    </author>
    <updated>2020-12-09T00:00:00Z</updated>
    <entry>
    <title>被造物の星の時間</title>
    <link href="https://vekatze.github.io/post/2020-12-09.html" />
    <id>https://vekatze.github.io/post/2020-12-09.html</id>
    <published>2020-12-09</published>
    <updated>2020-12-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<header>
    <h1>被造物の星の時間</h1>
    
    <span class="metadata">2020-12-09</span>
    
</header>

<div id="audio-player">
    
      <div id="cover-container">
          <img id="cover" class="cover" src="/media/atri-stellar.jpg"/>
          <div id="cover-overlay">
              <img id="play-button" src="/media/play-button-triangle.png" />
          </div>
      </div>
    
    <audio id="audio-player-internal" preload="auto" src="/media/被造物の星の時間.flac" />
</div>

<blockquote>
<p>文明は空の星を消すと言うけど<br />
その光は街に降りてきていたのさ<br />
造られたビリビリする星の向こうに<br />
ありとあらゆる命の比喩があるのさ</p>
</blockquote>
]]></summary>
</entry>
<entry>
    <title>ゼロのある音楽理論</title>
    <link href="https://vekatze.github.io/post/2020-10-27.html" />
    <id>https://vekatze.github.io/post/2020-10-27.html</id>
    <published>2020-10-27</published>
    <updated>2020-10-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<header>
    <h1>ゼロのある音楽理論</h1>
    
    <span class="metadata">2020-10-27</span>
    
</header>

<p>千年前ならいざ知らず、今日になって音楽理論を学ぼうとする人であれば、おそらくほとんど誰もがあの「音程」の定義に一度はつまずくんじゃないだろうか。「……なんである音とそれ自身とのあいだの距離が0じゃなくて1なの？」</p>
<p>自分はそうだった。もちろんあの定義にもなにかしらの必然性がありはするんだろうけど、少なくとも自分の関心から音楽理論をながめたとき、あの「距離で～す♡」みたいな顔をした、それでいて距離の公理すらみたさない謎の概念とよろしくやっていくのはしんどかった。「音を整数で表現して絶対値とればそれでよくね」などと思わずにはいられなかった。そしてこれは別に音程にかぎった話ではなくて、なんというか全体的に、もっと見通しよくやれるはずの場所で奇妙な遠回りを強いられている感じがぬぐえなかった。</p>
<p>というわけでこの記事は、平易な数学の言葉でポピュラー音楽理論を書き直すものとなっている。音を整数として定義するところから出発して、既存の曲を実際にあれこれ調べてみるところまでをやる。使うのは加減乗除と同値類くらい。我ながら、なかなか使い勝手のよいものになったんじゃないかと思う。</p>
<p>ところで、音楽理論についての本を1冊でも読んだことのある人であれば誰でも知っている通り、音楽理論って別にそんなにリロンリロンしたものではない。「音楽理論」の名のもとにおこなわれているのは、言ってみればあれこれの語彙を用意したうえで実際の楽曲にしばしばみられるパターンを分類するような作業であって、実態としてはノウハウ集に近い。</p>
<p>それはこの記事についても同じことで、数学っぽい言葉を使っているからって、特になにか「非自明な命題が得られてスゴい！」みたいな話があるわけではない。証明なんかひとつもなくて、ただ定義とその背景にある音楽的直観とが続く。ようするに、用意される言葉の雰囲気がことなるってだけで、本質的には通常の音楽理論とたいして変わっていない。とくに気負わずに読めると思う。</p>
<h2 data-toc=":include siblings :depth 2 :ignore (this)" id="toc">目次</h2>
<div class="CONTENTS drawer">
<ol>
<li><a href="#十二平均律での一般論">十二平均律での一般論</a>
<ol>
<li><a href="#音">音</a><br />
</li>
<li><a href="#音階">音階</a><br />
</li>
<li><a href="#調">調</a><br />
</li>
<li><a href="#和音">和音</a><br />
</li>
<li><a href="#正則和音特異和音">正則和音・特異和音</a><br />
</li>
<li><a href="#進行">進行</a><br />
</li>
</ol></li>
<li><a href="#いくつかの基本的な調とその性質">いくつかの基本的な調とその性質</a>
<ol>
<li><a href="#標準調">標準調</a><br />
</li>
<li><a href="#増調">増調</a><br />
</li>
<li><a href="#減調">減調</a><br />
</li>
</ol></li>
<li><a href="#進行の分類">進行の分類</a>
<ol>
<li><a href="#調の内部での進行">調の内部での進行</a><br />
</li>
<li><a href="#調の外部への進行">調の外部への進行</a><br />
</li>
</ol></li>
<li><a href="#既存曲をあれこれ調べてみる">既存曲をあれこれ調べてみる</a>
<ol>
<li><a href="#内田真礼youthful-beautiful">内田真礼『youthful beautiful』</a><br />
</li>
<li><a href="#相対性理論ミスパラレルワールド">相対性理論『ミス・パラレルワールド』</a><br />
</li>
<li><a href="#radioheadpyramid-song">Radiohead『Pyramid Song』</a><br />
</li>
</ol></li>
<li><a href="#跋">跋</a></li>
</ol>
</div>
<h2>十二平均律での一般論</h2>
<h3>音</h3>
<p><strong>定義:</strong> <code>Z</code> の元を <strong>原音</strong> とよぶ。 <code>Z/12Z</code> の元を <strong>音</strong> とよぶ。以下では原音 <code>z</code> の <code>mod 12</code> での同値類を <code>[z]</code> と書く。 □</p>
<h3>音階</h3>
<p><strong>定義:</strong> <code>Z/12Z</code> の狭義単調増加列であって、 <code>[0]</code> から始まるものを <strong>音階</strong> とよぶ。音階 <code>s</code> の <code>i mod (length s)</code> 番目の要素を <code>s&lt;i&gt;</code> と書く。 □</p>
<p>たとえば <code>s := ([0], [4], [7])</code> は音階であり、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>s&lt;0&gt; = [0]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>s&lt;1&gt; = [4]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>s&lt;2&gt; = [7]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>s&lt;3&gt; = [0]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>s&lt;4&gt; = [4]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>s&lt;5&gt; = [7]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>s&lt;6&gt; = [0]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<p>となる。他方、 <code>([0], [7], [4])</code> や <code>([1], [2], [3])</code> などは音階でない。</p>
<h3>調</h3>
<p><strong>定義:</strong> 音と音階のペアを <strong>調</strong> とよぶ。また、調 <code>(r, (s0, ..., sn))</code> に対し、集合</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>{r + s0, ..., r + sn}</span></code></pre></div>
<p>をその調の <strong>構成音集合</strong> とよぶ。 □</p>
<p>たとえば、調 <code>([8], ([0], [4], [7], [9]))</code> について、その構成音集合は、</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  {[8]+[0], [8]+[4], [8]+[7], [8]+[9]}</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>= {[8],     [0],     [3],     [5]}</span></code></pre></div>
<p>である。</p>
<h3>和音</h3>
<p><strong>定義:</strong> <code>Z/12Z</code> の部分集合であって <code>[0]</code> を含むものを <strong>相</strong> とよぶ。 □</p>
<p><strong>定義:</strong> 音と相のペアであって、相の濃度が <code>n</code> であるものを <strong>n和音</strong> またはたんに <strong>和音</strong> とよぶ。和音の第1成分をその和音の <strong>根</strong> とよぶ。和音 <code>(r, {t0, ..., tn})</code> に対し、集合</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>{r + t0, ..., r + tn}</span></code></pre></div>
<p>をその和音の <strong>構成音集合</strong> とよぶ。相 <code>X, Y</code> について、その和集合をたんに <code>XY</code> とも書く。また、和音 <code>(r, t)</code> をたんに <code>rt</code> とも書く。 □</p>
<p>基本的な相を次のように定めておく：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>d := {[0], [3], [6]}  # diminished</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>m := {[0], [3], [7]}  # minor</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>M := {[0], [4], [7]}  # major</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>a := {[0], [4], [8]}  # augmented</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>- := {[0], [10]}</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>+ := {[0], [11]}</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>s := {[0], [2], [7]}  # suspended</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>S := {[0], [5], [7]}  # suspended</span></code></pre></div>
<p>たとえば <code>[4]m- = ([4], {[0], [3], [7], [10]})</code> である。またこの和音の構成音集合は</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>{[4]+[0], [4]+[3], [4]+[7], [4]+[10]}</span></code></pre></div>
<p>すなわち</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>{[4], [7], [11], [2]}</span></code></pre></div>
<p>となる。</p>
<p><strong>定義:</strong> 和音 <code>c</code> の構成音集合が調 <code>k</code> の構成音集合に含まれるとき、 <strong>和音 <code>c</code> は 調 <code>k</code> の和音である</strong> または <strong>和音 <code>c</code> は調 <code>k</code> において表現可能である</strong> という。 □</p>
<p><strong>定義:</strong> 和音 <code>c1, c2</code> について、両者の構成音集合が同一であるとき、両者は <strong>同値</strong> であるといい、 <code class="verbatim">c1 ~ c2</code> と書く。また、 <code class="verbatim">c1 ~ c2</code> であるとき、和音 <code>c1</code> は和音 <code>c2</code> の <strong>転回形</strong> であるという。和音 <code>c</code> の転回形であって、根が <code>a</code> であるものを <code>c/a</code> と書く。 □</p>
<p>たとえば和音 <code>c = ([4], {[0], [3], [7], [10]})</code> について、これの転回形 <code>c/[4+3]</code> を次のように構成することができる。まず、 <code>c</code> の構成音集合は</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  {[4]+[0], [4]+[3], [4]+[7], [4]+[10]}</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>= {([4]+[3])-[3]+[0], [4]+[3], ([4]+[3])-[3]+[7], ([4]+[3])-[3]+[10]}</span></code></pre></div>
<p>である。したがって和音</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  ([4]+[3], {-[3]+[0], [0], -[3]+[7], -[3]+[10]})</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>= ([7], {[9], [0], [4], [7]})</span></code></pre></div>
<p>はもとの和音と同一の構成音集合をもつ。これによって和音 <code>c/[4+3]</code> が構成される。この構成はもちろん <code>[0], [7], [10]</code> に対してもおこなうことができて、ゆえに上記の手順によって <code>c</code> の転回形として <code>c/[4+0], c/[4+3], c/[4+7], c/[4+10]</code> の4つを構成することができる。ここでもちろん <code>c = c/[4+0]</code> である。</p>
<h3>正則和音・特異和音</h3>
<p><strong>定義:</strong> 調 <code>(r, s)</code> に対し、和音</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(r + s&lt;i&gt;, {s&lt;i + 2 * 0&gt; - s&lt;i&gt;, ..., s&lt;i + 2 * (n - 1)&gt; - s&lt;i&gt;})</span></code></pre></div>
<p>を、この調における位置 <code>s&lt;i&gt;</code> の <strong>狭義正則n和音</strong> またはたんに <strong>狭義正則和音</strong> とよび、 <code>Reg(r, s, s&lt;i&gt;, n)</code> と書く。ある調の狭義正則n和音に同値な和音を、その調の <strong>正則n和音</strong> または <strong>正則和音</strong> とよぶ。ある調の和音であって正則和音でないものをその調の <strong>特異和音</strong> とよぶ。 □</p>
<p>正則和音について補足しておく。上記のような正則和音の構成音集合は、</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>{r + s&lt;i + 2 * 0&gt;, ..., r + s&lt;i + 2 * (n - 1)&gt;}</span></code></pre></div>
<p>となる。すなわち、正則和音とは、調のなかのある特定の音からスタートして、上方向に音を音階に沿って1つおきにとることで構成される和音である。たとえば、調</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>([5], ([0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11]))</span></code></pre></div>
<p>について、この調における位置 <code>[3]</code> の（狭義）正則4和音は、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  ([5] + [3], {[3] - [3], [5] - [3], [7] - [3], [9] - [3]})</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>= ([5] + [3], {[0],       [2],       [4],       [6]})</span></code></pre></div>
<p>である。</p>
<h3>進行</h3>
<p><strong>定義:</strong> 調 <code>k</code> と和音 <code>c</code> のペア <code>(k, c)</code> であって、 <code>c</code> が <code>k</code> の和音であるものを <strong>状況</strong> とよぶ。状況の有限列を <strong>進行</strong> とよぶ。文脈から調が明らかであるときは状況 <code>(k, c)</code> をたんに <code>c</code> と書く。 □</p>
<p><strong>定義:</strong> 進行 <code>p</code> における部分列 <code>(k1, c1) -&gt; (k2, c2)</code> について、 <code>k1 ≠ k2</code> であるとき、その部分列を <strong>転調</strong> とよぶ。 □</p>
<h2>いくつかの基本的な調とその性質</h2>
<h3>標準調</h3>
<p><strong>定義:</strong> 音階 <code>std := ([0], [2], [4], [5], [7], [9], [11])</code> を <strong>標準音階</strong> とよぶ。調 <code>(r, std)</code> を <strong>r-標準調</strong> とよび、 <code>Std(r)</code> と書く。 □</p>
<p>これはいわゆる「ドレミファソラシド」に対応している。「ド」から数えた「半音」の数がそれぞれの音に対応している。</p>
<p>ある標準調を平行移動して得られる調について考えることはしばしば有用になる。そこで次のように定義しておく：</p>
<p><strong>定義:</strong> <code>r</code>-標準調に対し、 <code>(r + a)</code>-標準調をもとの標準調の <strong><code>a</code>-関係調</strong> とよぶ。 □</p>
<p>また、のちのち有用であるので、ここで <code>[z]</code>-標準調における正則4和音を列挙しておく。定義に沿って素直に計算すればよい：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [0],  4) = ([ 0+z], {[0], [4], [7], [11]}) =  [0+z]M+</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [2],  4) = ([ 2+z], {[0], [3], [7], [10]}) =  [2+z]m-</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [4],  4) = ([ 4+z], {[0], [3], [7], [10]}) =  [4+z]m-</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [5],  4) = ([ 5+z], {[0], [4], [7], [11]}) =  [5+z]M+</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [7],  4) = ([ 7+z], {[0], [4], [7], [10]}) =  [7+z]M-</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [9],  4) = ([ 9+z], {[0], [3], [7], [10]}) =  [9+z]m-</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [11], 4) = ([11+z], {[0], [3], [6], [10]}) = [11+z]d-</span></code></pre></div>
<p>正則和音のうちのいくつかは実際の曲のなかで主要な役割をはたす。これらに名前を与えておく：</p>
<p><strong>定義:</strong> 標準調における位置 <code>[0]</code> の正則和音を <strong>主和音</strong> (tonic) とよぶ。標準調における位置 <code>[5]</code> の正則和音を <strong>下属和音</strong> (subdominant) とよぶ。標準調における位置 <code>[7]</code> の正則和音を <strong>属和音</strong> (dominant) とよぶ。 □</p>
<p>ところで、正則和音は音階から音を1つおきにとることで構成されるものであった。これはすなわち、音階における <code>i</code> 番目の正則和音と、 <code>i ± 2</code> 番目の正則和音とが似通った構成音集合をもつということである。そして似通った構成音集合をもつとはすなわち似通った響きをもつということでもあり、このような背景のもと、次の定義がおこなわれる：</p>
<p><strong>定義:</strong> 標準調における位置 <code>[9], [4]</code> の正則和音を <strong>代理主和音</strong> とよぶ。標準調における位置 <code>[2], [9]</code> の正則和音を <strong>代理下属和音</strong> とよぶ。標準調における位置 <code>[4], [11]</code> の正則和音を <strong>代理属和音</strong> とよぶ。 □</p>
<p>主和音を記号 <code>T</code>, 代理主和音を記号 <code>t</code>, 下属和音を記号 <code>S</code>, 代理下属和音を記号 <code>s</code>, 属和音を記号 <code>D</code>, 代理属和音を記号 <code>d</code> で表すとき、標準調におけるそれぞれの正則和音の機能は次のようにまとめられる：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [0],  4) =  [0+z]M+; T</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [2],  4) =  [2+z]m-; s</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [4],  4) =  [4+z]m-; t&amp;d</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [5],  4) =  [5+z]M+; S</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [7],  4) =  [7+z]M-; D</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [9],  4) =  [9+z]m-; t&amp;s</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>Reg([z], std, [11], 4) = [11+z]d-; d</span></code></pre></div>
<p>ここで <code>t&amp;d</code> は「 <code>t</code> でも <code>d</code> でもある」の意である。 <code>t&amp;s</code> についても同様。</p>
<p>以下、ある和音 <code>c</code> が主和音であることを、「和音 <code>c</code> の機能は <code>T</code> である」とも表現する。主和音以外のものについても同じように表現する。</p>
<h3>増調</h3>
<p><strong>定義:</strong> 音階 <code>aug := ([0], [3], [4], [7], [8], [11])</code> を <strong>増音階</strong> とよぶ。調 <code>(r, aug)</code> を <strong><code>r</code>-増調</strong> とよぶ。増調の正規和音を <strong>増和音</strong> とよぶ。 □</p>
<p>増音階は、根から音を「3, 1, 3, 1, …」の間隔で並べたものになっている。</p>
<p>増調 <code>([z], aug)</code> における正則和音を列挙すると次のようになる：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Reg([z], aug, [0],  3) = [z + 0]a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>Reg([z], aug, [3],  3) = [z + 3]a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>Reg([z], aug, [4],  3) = [z + 4]a</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>Reg([z], aug, [7],  3) = [z + 7]a</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>Reg([z], aug, [8],  3) = [z + 8]a</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>Reg([z], aug, [11], 3) = [z + 11]a</span></code></pre></div>
<h3>減調</h3>
<p><strong>定義:</strong> 音階 <code>dim := ([0], [2], [3], [5], [6], [8], [9], [11])</code> を <strong>減音階</strong> とよぶ。調 <code>(r, dim)</code> を <strong><code>r</code>-減調</strong> とよぶ。減調の正規和音を <strong>減和音</strong> とよぶ。 □</p>
<p>減音階は、根から音を「2, 1, 2, 1, …」の間隔で並べたものである。</p>
<p>減調 <code>([z], dim)</code> における正則和音を列挙すると次のようになる：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [0],  3) = [z + 0]d</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [2],  3) = [z + 2]d</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [3],  3) = [z + 3]d</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [5],  3) = [z + 5]d</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [6],  3) = [z + 6]d</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [8],  3) = [z + 8]d</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [9],  3) = [z + 9]d</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>Reg([z], dim, [11], 3) = [z + 11]d</span></code></pre></div>
<h2>進行の分類</h2>
<p>楽曲を分析するにあたり、頻出するパターンに名前があると便利である。以下ではそういった名前を提供する。</p>
<h3>調の内部での進行</h3>
<h4>正則和音だけによるもの</h4>
<p>以下、進行を書くにあたって、和音を書くべき場所に <code>T</code> や <code>s</code> などの記号が書いてあるときは、それは当該の機能を持つ任意の正則和音を表現したものとする。また、 <code>D|d</code> などは「 <code>D</code> または <code>d</code> 」の意とする。</p>
<p><strong>定義:</strong> <code>r</code>-標準調における以下の進行を <strong>終止</strong> とよぶ。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>D|d -&gt; T|t</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>S|s -&gt; T|t</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>S|s -&gt; D|d -&gt; T|t</span></code></pre></div>
<p><code>r</code>-標準調における以下の終止をとくに <strong>完全終止</strong> と呼ぶ。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>D|d -&gt; T</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>S|s -&gt; T</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>S|s -&gt; D|d -&gt; T</span></code></pre></div>
<p><code>r</code>-標準調における以下の終止をとくに <strong>偽終止</strong> と呼ぶ。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>D|d -&gt; t</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>S|s -&gt; t</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>S|s -&gt; D|d -&gt; t</span></code></pre></div>
<p>□</p>
<p>音楽的直観としては、完全終止は素直に曲の終わりをあたえるとされる一方で、偽終止はどこか終わっていないような、意外な感じをあたえるとされる（私もそう直観する）。</p>
<p>基本的には、楽曲は上記の終止が組み合わせられたものとして分析されることになる。というか、そうした枠組みのもとで曲を調べていく。まあ世の中にはぜんぜん終止してない曲も無数にあるので、上記の形式に当てはまっていないからといってそこまで気にする必要はない。「あ、ここ、通常の終止になってるね」と気付けるようになると構造がみてとりやすくなってうれしい、くらいでよい。</p>
<p>関連して明言しておくと、別に上記以外の進行が誤りというわけではない。たとえば <code>D -&gt; S</code> の進行は古典和声で「禁則進行」とよばれるものに該当しているが、ポピュラー音楽ってのは気持ち悪い響きが気持ちいい世界であり、たとえば曲を書いているときに禁則進行のほうが善いと感ぜられたならば、それはもう迷わずそっちを選べばよい。</p>
<p>ただ、特殊なものを特殊なものとして認識することには一定の美徳がたぶんある。意図をもって逸脱しましょう。</p>
<h4>特異和音にもよるもの</h4>
<p>特異和音のなかでも和音 <code>[z]S</code> を利用した進行はしばしば用いられる。音楽的直観としては、この和音は「期待させる音について、それを鳴らすのを遅らせる」ものである。たとえば通常の終止 <code>[7]M- -&gt; [0]M</code> について、これを <code>[7]M- -&gt; [0]S -&gt; [0]M</code> に書き換える、といった仕方で用いられる。これによって遅延解決の響きが得られる。 <code>[7]M-</code> の不安定な響きが解決されるのを期待させておいて、その解決を <code>[0]S</code> でいったんおあずけするような雰囲気になる。</p>
<p>もちろん別に使う場所は <code>[0]</code> じゃなくてもよくて、 <code>[2]</code> または <code>[7]</code> でもいい（これらはどちらも現在考えている標準調の和音になる）。 <code>[2+z]S -&gt; [2+z]m-</code>, という具合である。</p>
<p>また、もう一つ、 <code>[z]S</code> ほどではないが、 <code>[z]s</code> もたまに用いられる。この和音がもつ音楽的直観は <code>[z]S</code> と同様で、つまり解決の遅延である。音楽的直観がだいたい一緒なら <code>[z]S</code> だけつかってりゃよくね、という気がしそうなところだが、これは案外そうでもない。たとえば</p>
<ul>
<li><code>[0]S -&gt; [0]M</code><br />
</li>
<li><code>[0]s -&gt; [0]M</code><br />
</li>
</ul>
<p>という2つの遅延解決を比べてみると、前者では構成音が <code>[5] -&gt; [4]</code> と下がる方向に動くのに対し、後者では <code>[2] -&gt; [4]</code> と上がる方向に動く。これもあって、前者がいくらかリラックスした響きをまとう一方で、後者はいくらか元気な響きをまとう。こうした響きの差異はしばしば有用で、曲想に合わせて使い分けてゆきましょう、という話になる。</p>
<h3>調の外部への進行</h3>
<h4>別な標準調をとるもの</h4>
<p>ある標準調を基準としたとき、別な関係調の和音であって「なんだかうまくいく」もの、よく用いられるものはおおむね決まっている。ここではそれらの慣例名をまとめておく。</p>
<p><strong>定義:</strong> <code>[3]</code>-関係調における位置 <code>[2]</code> の和音を、もとの標準調における <strong>サブドミナント・マイナー</strong> とよぶ。この和音はもとの標準調で言うところの <code>[5]m-</code> の和音になり、その機能は <code>s</code> とされる。 □</p>
<p><strong>定義:</strong> <code>[6]</code>-関係調における位置 <code>[7]</code> の和音を、もとの標準調における <strong>裏コード</strong> とよぶ。この和音はもとの標準調で言うところの <code>[1]M-</code> の和音になり、その機能は <code>d</code> とされる。 □</p>
<p><strong>定義:</strong> <code>[8]</code>-関係調における位置 <code>[5]</code> の和音を、もとの標準調における <strong>ナポリの六度</strong> とよぶ。この和音はもとの標準調で言うところの <code>[1]M+</code> の和音になり、その機能は <code>d</code> とされる。 □</p>
<p><strong>定義:</strong> <code>[9]</code>-関係調における位置 <code>[0]</code> の和音を、もとの標準調における <strong>ピカルディの三度</strong> とよぶ<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。この和音はもとの標準調で言うところの <code>[9]M+</code> の和音になり、その機能は <code>t</code> とされる。 □</p>
<p><strong>定義:</strong> <code>z</code> を <code>std</code> の要素とする。このとき、 <code>[z]</code>-関係調における位置 <code>[7]</code> の和音を、位置 <code>[z]</code> の和音についての <strong>二次属和音</strong> とよぶ。この和音はもとの標準調でいうところの <code>[z+7]M-</code> の和音になり、その機能は位置 <code>[7]</code> の和音に対する <code>d</code> とされる。 □</p>
<p>上記の和音はしばしばまるでもとの標準調にそなわった正則和音であるかのように用いられる。これらの特殊な和音も含め、ある標準調においてよく用いられる和音を位置ごとにまとめると次のようになる。これは楽曲分析にあたって有用な図になる：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a> position | regular       secondary-dominant                other</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>----------+---------------------------------------------------------------</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    [0]   |  [0]M+               [0]M-</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    [1]   |                                             [1]M-   [1]M+</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    [2]   |  [2]m-               [2]M-</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    [3]   |---------------------------------------------------------------</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    [4]   |  [4]m-               [4]M-</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    [5]   |  [5]M+                                          [5]m-</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    [6]   |                      [6]M-</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    [7]   |  [7]M-              ([7]M-)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    [8]   |---------------------------------------------------------------</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    [9]   |  [9]m-               [9]M-                      [9]M+</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>   [10]   |---------------------------------------------------------------</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>   [11]   | [11]d-              [11]M-</span></code></pre></div>
<p>なお、もちろん別に上にある和音（を第2成分にもつような状況）以外への転調が禁じられているわけではない。特に、 <code>[±3]</code>-関係調、 <code>[±5]</code>-関係調への転調は自然におこなうことができ、しばしばみられる。</p>
<p>上記以外に特筆すべき転調のパターンとしては、 <code>S</code> の和音を利用したものが挙げられる。ポイントは、 <code>[2+z]S</code> を単独でみたとき、これは <code>[z]</code>-標準調における和音 <code>[2+z]S</code> なのか、それともその <code>[2]</code>-関係調における和音 <code>[0+(z+2)]S</code> なのか、区別がつかないということである。つまり、</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>key:[z]     key:[z+2]     key:[z+2]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>-------     ----------    -----------</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>[2+z]S   =  [0+(z+2)]S -&gt; [0+(z+2)]M+</span></code></pre></div>
<p>という具合で <code>[2]</code>-関係調への転調をなめらかに実現することができる。これは通常の <code>[z]</code>-標準調における遅延解決と比べてみるとよりわかりやすいかもしれない：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>key:[z]     key:[z+2]     key:[z+2]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>-------     ----------    -----------     ([2+z]Sの区別不可能性による転調 + [2]-関係調での位置[0]での遅延解決)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>[2+z]S   =  [0+(z+2)]S -&gt; [0+(z+2)]M+</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>key:[z]                   key:[z]</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>------                    -------         (もとの標準調での位置[2]での遅延解決)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>[2+z]S                 -&gt; [2+z]m-</span></code></pre></div>
<p>転調によって <code>m</code> の和音に解決するかわりに <code>M</code> の和音に解決していることがみてとれると思う。</p>
<p>その他、それ以外の和音についても、まあ好きに転調すればよろしい。</p>
<h4>別な非標準調をとるもの</h4>
<p>その他、関係調でなく、増調や減調へと転調することももちろん可能である。標準調における和音と構成音がよく似た増和音・減和音を利用したくなったときにそうした転調をおこなうわけだけど、「じゃあいつそんなよくわかんない和音がほしくなるの」ってのはごくまっとうな疑問だと思う。実際、鳴らしてみるとわかるが、増和音も減和音もなかなか異様な響きをもった代物で、一見するとあつかいづらそうではある。</p>
<p>結論から言うと、基本は「1だけ変わるような音の動き」を実現したいときである。増和音 <code>[z]a = ([z], {[0], [4], [8]})</code> について考える。まず、 <code>M</code> と <code>m</code> はともに <code>[7]</code> を含んでいた。これはすなわち、 <code>M</code> や <code>m</code> の和音から、それと根を同一とするような増和音へといたるような進行を考えると、 <code>[7] -&gt; [8]</code> といううなめらかな進行が実現できることになる。ゆえにたとえば</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>[z]m -&gt; [z]a -&gt; [z+2]M</span></code></pre></div>
<p>のような進行をとれば、この進行において、構成音の一部が</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>[z+7] -&gt; [z+8] -&gt; [z+7+2]</span></code></pre></div>
<p>つまり</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>[z+7] -&gt; [z+8] -&gt; [z+9]</span></code></pre></div>
<p>のように、なめらかに上行することになる。こうした動きはたとえば曲をゆっくりと緊張させたいときに有用である。</p>
<p>減和音 <code>[z]d = ([z], {[0], [3], [6]})</code> についても基本は同様で、こちらは下がる方向の動きになる。まあようするに、これらの和音および調は、基本的にはなめらかな動きを作りたいときに利用すればよろしい。もちろんそれ以外の場面でつかっても牢屋にぶち込まれたりはしないし、好きに鳴らせばいいんだけど。</p>
<p>ところで減和音にはもうひとつ特筆すべき用法がある。標準調を導入したときにみたとおり、 <code>[11+z]d</code> は代理属和音であった。ここで減和音 <code>[11+z]d</code> は <code>[z]</code>-減調における正規和音であるので、減調において「1つ飛んだ」場所にある和音 <code>[11+z±3]d</code> と似た響きを示す。つまり <code>[11+z]d</code> は <code>[8+z]d</code> や <code>[2+z]d</code> と似た響きを示す。これによって、根が <code>[2+z]</code> や <code>[8+z]</code> であるような和音であって、属和音にいくらか近い機能をもったものが得られる。これは和音の根をなめらかに動かしたいときなどにけっこう便利だったりする。</p>
<h2>既存曲をあれこれ調べてみる</h2>
<p>以下ではここまでに用意した語彙を用いて実際に既存の曲を調べていく。が、その前に、いくつかの言葉を用意しておく。まず、楽曲に対し、それに合う進行をあたえること、およびそれにともなう行為を楽曲の <strong>分析</strong> とよぶことにする。また、進行に対し、そこになんらかの構造や機能を見出すこと、およびそれにともなう行為を進行の <strong>総合</strong> とよぶことにする。そしてさらに、楽曲を分析して得られた進行を総合する行為、およびその結果を楽曲の <strong>解釈</strong> とよぶことにしてみる。</p>
<p>注意すべき点として、分析の結果は一意的でない。たとえばいわゆる「ド・ミ・ソ」の音が鳴っていたとする。この和音はたとえば <code>[0]</code>-標準調における位置 <code>[0]</code> の正則和音 <code>[0]M</code> として解釈することができる。けれども他方、別に、この和音を調</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>([3], ([0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11]))</span></code></pre></div>
<p>における特異和音のひとつであると分析することをさまたげるものは、論理的にはなにもない。——が、それが楽曲のもつ響きを説明するにあたって有用であるか、もとの楽曲に合っているかはまた別の話である。</p>
<p>分析は別に作曲者の手によって楽譜に記された一連の記号列を再構成すべくしてあるような行為ではない。むしろそれは、自分がある楽曲をどのように理解したのか、どのような関節に沿って切り離したのかを表現する行為である（分節化）。ある和音が上記のような奇妙な仕方で分析されたとして、それはその分析をおこなった人がその和音を奇妙な仕方で理解したことのしるしである。</p>
<p>言い換えるなら、解釈とは「この曲はこういう構造をしているからこういう響きをしている」ではなく「私はこういう響きを感じたんだけど、これは私がこういう構造を曲のなかに見出したことによると思う」を表現する行為である。すなわち解釈は一種の自己紹介であって、正しい解釈と正しくない解釈があるというよりは、説得的な解釈とそうでもない解釈とがある。</p>
<p>たとえば、ベースが派手に動く楽曲がどのような進行をもつかをめぐっては、しばしば意見がばらつく。これはごく自然なことである。ベースが激しく動くことはそのぶんだけベースラインが不明瞭になることであり、ベースラインが不明瞭になることは進行が不明瞭になることであるから。「正しい進行があるんだけど、それがわかりづらくなっている」というよりは、ベースの激しい動きによって、いわば不明瞭な進行そのものがその曲の「真の」進行になっている。こうした楽曲を分析するとき、われわれはそもそもからして不明瞭な進行を前にして明瞭な進行をひとつ示しているわけで、それはまあ、意見がばらつくのも当然であろう。そこに正誤を問うてもあまり得るところはあるまい。</p>
<p>だから自分で楽曲を調べて作ってみた進行が、たとえばなにか検索してみてひっかかった進行とちがっていたからといって、間違えてしまったとか思う必要は基本的にはない（そりゃ、調が違うとかになるとさすがに修正は必要だけど）。むしろそういうときにやるべきは、その誰かによる進行がどのような解釈のもとにあるかを考えること、それが自分の解釈と比べてどのようにすぐれているか、どのようにすぐれていないかを比較検討することだろう。</p>
<p>ようするに、なにが言いたいかって、「楽曲の解釈においてはあまりにも開かれた選択を迫られる場面が多々あるけれど、解釈が自己紹介である以上、そういうときに澪標になるのはひとえに自分が楽曲から感じ取った響きだけだよ」ってことである。そしてまた、この「どう感じたかが大事」が、なにかロマン主義的なスローガンにとどまるものじゃなく、もっとドライな事実、テクニカルな次元の話だってことである。伝わるだろうか。</p>
<p>まあ、なんにせよ、実際の曲を調べてみましょう。</p>
<h3>内田真礼『youthful beautiful』</h3>
<p><a href="https://www.youtube.com/watch?v=z6-MIsN8gwE">https://www.youtube.com/watch?v=z6-MIsN8gwE</a></p>
<p>最初の題材はこの素直でポップな曲にしてみる（なんか走ったりする感じのPVですね）。構造を調べていくとわかるが、この曲は、込み入った技法をひかえつつ、曲想と絡み合った形で最低限の意外性を組み込んだようなものになっていて、私はこういうものもたいへん好ましいと思う。リラックスした美しさがある。</p>
<p>以下、実際に解釈をおこなっていく。</p>
<h4>調の確定</h4>
<p>だいたいの曲は標準調で書かれる。この曲もそうであると仮定し、まずはどの標準調にあるのかを確定していく。そのためには曲の中で使われている音を集めてゆけばよい。</p>
<p>歌い出しの「崩れてしまいそう」は <code>[0], [2], [3], [5], [10]</code> から構成されている（ここで、いわゆる「ド」を <code>[0]</code>, 「ドのシャープ」を <code>[1]</code>, …, 「シ」を <code>[11]</code> に対応づけている。以下同じ）。</p>
<p>少し行ったところの「誰も知らないんだな」みたいなフレーズはありがたくて、こういう音階を素直に上にたどっていってくれるようなやつがあると音が拾いやすい。ここは <code>[0], [2], [3], [5], [7], [8]</code> から構成されている。</p>
<p>両者を合わせて、 <code>[0], [2], [3], [5], [7], [8], [10]</code> が利用可能な音であることがわかる。あとはこれが構成音集合であるような <code>r</code>-標準調をみつければよい。どう見つけてもよいが、手っ取り早いのはこれら利用可能な音に含まれる <code>([2], [3])</code> および <code>([7], [8])</code> という2つの「距離1のペア」に注目する路線だと思う。一般に、 <code>r</code>-標準調は</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(r, ([0], [2], [4], [5], [7], [9], [11]))</span></code></pre></div>
<p>という形をしたものであった。つまり、 <code>r</code>-標準調は距離1の音のペアとして <code>(r+[11], r+[0])</code> と <code>(r+[4], r+[5])</code> をもつことになる。これと <code>([2], [3])</code> および <code>([7], [8])</code> を比べてやれば、 <code>[3]+[5] = [8]</code> が成立することにより <code>r=[3]</code> であることがわかる。</p>
<p>というわけでこの曲は <code>[3]</code>-標準調である。</p>
<h4>イントロ</h4>
<p>イントロを調べていく。分析について。まず最初のギターのｼﾞｬｰﾝという和音の根は <code>[3]</code> である（単音であるかのように聞けばよい）。他の楽器が入ってくるところは、ベースに注目すれば <code>[8] -&gt; [10] -&gt; [0] -&gt; [3]</code> の2回の繰り返しであるとわかる。これは次のように書き換えても同じことである：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>[0+3] -&gt; ([5+3] -&gt; [7+3] -&gt; [9+3] -&gt; [0+3]) * 2</span></code></pre></div>
<p>こう書き換えてやるとそれぞれの和音の機能がみてとりやすくなる。つまり、 <code>[3]</code>-標準調の正則和音だけが使用されていると仮定すれば、イントロの進行は、</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>[0+3]M+ -&gt; ([5+3]M+ -&gt; [7+3]M- -&gt; [9+3]m- -&gt; [0+3]M+) * 2</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  T           S          D         t&amp;s         T</span></code></pre></div>
<p>であるということになる。 <code>0, 5, 7, 9</code> の部分に注目するって話。 <code>[n+3]</code> の形に書き換えてやることで <code>[0]</code>-標準調における正則和音の議論へと話を帰着することができる。</p>
<p>あとはこの進行を手元の楽器等で鳴らしながら曲で鳴っている音との整合性をチェックする。問題がなければイントロの分析はこれで終了する。今回は実際問題なさそうなのでイントロの分析がここで終わる。</p>
<p>総合について。まずここでの進行における <code>t&amp;s</code> の機能を <code>t</code> とみなすことで、イントロの <code>S -&gt; D -&gt; t</code> の部分を偽終止として理解する。つまり <code>S -&gt; D -&gt; t -&gt; T</code> を、 <code>S -&gt; D -&gt; t</code> までの偽終止でやや意外な、まだ続くようなニュアンスを出しておいた上で、 <code>T</code> できちんと終了する、というサイクルであると理解する。</p>
<p>この総合が実際の音楽を説明しているかを検討する。実際にイントロを聞き直してみる。まず冒頭のｼﾞｬｰﾝ2回はよろしい。主和音の安定感がある。では <code>S -&gt; D -&gt; t -&gt; T</code> の繰り返しのほうはどうかと聞いてみると <code>t</code> にあたる場所で、たしかになにかが続きそうなニュアンスが残っていること、およびその続きそうなニュアンスが <code>T</code> で解決していることが—「私の」音楽的直観によって—確認できる。なのでイントロの総合がこれで終わる。</p>
<p>ちなみに、この部分の進行は <code>mod 12</code> を利用して</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>[5+3]M+ -&gt; [7+3]M- -&gt; [9+3]m- -&gt; [12+3]M+</span></code></pre></div>
<p>と書き直すとより音楽的直観に沿ったものになると思う。つまり、下属和音からスタートしてどんどん上がっていくような進行。さらに言うと、標準調における位置 <code>[11]</code> の正則和音はあまり用いられないので、結局、これは下属和音から音階に沿って1つずつ順番に上行するような進行だと言ってしまってよい。</p>
<p>まとめておくと、このイントロの音楽的意義は、偽終止を「上側」の主和音によって二重に解決することで、気分を高揚させるような機能を実現しているところにある（と「私は」思う）。</p>
<h4>Aメロ（1）</h4>
<p>Aメロを調べていく。分析について。「崩れてしまいそう」の後ろのギターに注目して、 <code>[8] -&gt; [10] -&gt; [0] -&gt; [3]</code> が見える。それ以降も同様で、また特に変な技法が用いられているような響きも存在しない。というわけで進行はイントロと同様のものとして分析される。総合も同様。</p>
<h4>Bメロ（1）</h4>
<p>Bメロを調べていく。まず「思い出せなくっても」から「繋がれていた」までは、ベースが素直に、 <code>[8] -&gt; [10] -&gt; [0] -&gt; [3]</code> と上行していく。とくに奇妙な響きもなく、ゆえにここもイントロと同様の進行として分析・総合される。</p>
<p>続く「明日明後日」について。分析としては、ここでの進行をとるにはベース（または右チャンネルのギターのアルペジオの最低音）に注目すればよく、 <code>[5] -&gt; [7] -&gt; [8]</code> が見える。で、これは</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>[2+3] -&gt; [4+3] -&gt; [5+3]</span></code></pre></div>
<p>と書き換えても同じことで、だからここは正規和音によって</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>[2+3]m- -&gt; [4+3]m- -&gt; [5+3]M-</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  s         t&amp;d         S</span></code></pre></div>
<p>と仮定され、とくに奇妙な響きもないので、この部分は上記のように分析される。</p>
<p>総合としては、真ん中の <code>t&amp;d</code> をどちらで解釈するかという問題はあるが、ここにはあまりこだわらなくてもよいように思う。むしろこの箇所の要点は終止らしい終止をおこなっていないということそれ自体である。和音の根自体が <code>[5] -&gt; [7] -&gt; [8]</code> と上行していることとも相まって、ここではポップスのBメロらしい盛り上がっていく感じ、サビを期待させる感じが演出されていると言ってよい。</p>
<p>「その先だって 隣で」について。分析としては、まず進行は <code>[5] -&gt; [7]</code> までは一緒。「先だって」の「て」は <code>[8]</code> で、続く「隣で」で <code>[7]</code> に下行している（ベースに注目）。だからまとめると <code>[5] -&gt; [7] -&gt; [8] -&gt; [7]</code> となって、で、これは</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>[2+3] -&gt; [4+3] -&gt; [5+3] -&gt; [4+3]</span></code></pre></div>
<p>と書き換えても同じことで、だから正規和音によって</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>[2+3]m- -&gt; [4+3]m- -&gt; [5+3]M+ -&gt; [4+3]m-</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  s         t&amp;d         S         t&amp;d</span></code></pre></div>
<p>と仮定され、奇妙な響きの和音もないので、こうしてBメロの分析が終わる。</p>
<p>総合であるが、注目するべきは、これまでの進行がすべて上行していたという点である。イントロから始まってここにいたるまで、ひとつの例外もなく。</p>
<p>にもかかわらず「その先だって」の直後、サビの直前というポップス的に一番大事なところで初めての下行がおこなわれる。偽終止 <code>S -&gt; t</code> と読んでよかろう。これは聞いている人の意表を突くものである。そしてこっちが下行および偽終止にびっくりしているところ、スキをつくったところに、内田真礼が「なんか問題ある？」とでも言わんばかりに、のびのびとした歌声をめちゃめちゃ楽しそうに聞かせてくる。曲想と構造がきれいに噛み合っており、これがBメロ末尾の美しさになっている。のびのびとした内田真礼によってのみ救いうるものがある。</p>
<p>まとめておくと、このBメロの音楽的意義は、これまでの上行を引き継ぐようにして上行を繰り返したうえで、サビに入る直前で曲の中で初めての下行をおこない、意外性をもって受け手のガードを崩すところにある。「明日明後日」以降で終止らしい終止が最後の特殊なもの以外に存在しないこともこの意外性に寄与していると言ってよい。</p>
<h4>サビ（1）</h4>
<p>サビを調べていく。まず「君が待っていてもいなくても走るよ」であるが、分析としては、ベースに注目して <code>[8] -&gt; [10] -&gt; [0] -&gt; [3]</code> が見える。特にこれといって特殊な響きもなく、ゆえにイントロと同様の進行として分析される。</p>
<p>総合について。ここのポイントは「凝ったことをしない」ことそれ自体であるといってよい。工夫はすでに直前において終わっており、ここではリラックスした進行のなかで内田真礼のもつ善が存分に発揮され、ガードを崩された聴衆は「君が待っていてもいなくても走るよ」をもろに食らう。われわれはケアルガで死ぬゾンビになる。</p>
<p>「このまま足を動かせば光になる」について。分析としては、まずベースに注目して <code>[8] -&gt; [7] -&gt; [0] -&gt; [10] -&gt; [3]</code> が見える。そしてここにはこれといって奇妙な響きはなく、なのでこれは正則和音から</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>[5+3]M+ -&gt; [4+3]m- -&gt; [9+3]m- -&gt; [7+3]M- -&gt; [0+3]M+</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  S         t&amp;d        t&amp;s         D          T</span></code></pre></div>
<p>と分析してよい。</p>
<p>総合としては、まず最後の <code>D -&gt; T</code> の部分が完全終止であることが目を引く。他方で前半の3つは <code>S -&gt; d -&gt; t</code> と読めば偽終止である。つまりこのフレーズは2つの基本的な終止を組み合わせたものとなっている。これは実際の響きにも整合的であるように（「私には」）思われる。偽終止のあとにすぐさまもう一回コンパクトな <code>D -&gt; T</code> を入れることで二重に終止するような進行になっている。素直な響きのための素直な進行であると言ってよい。</p>
<p>「すぐに消えそうな一瞬はこんなにも」について。ここは聞けば分かる通り「君が待っていてもいなくても走るよ」と同じ。</p>
<p>「美しかったか 愛せていたか」について。分析としては、まずベースから <code>[8] -&gt; [10] -&gt; [7] -&gt; [0]</code> が拾える。そしてまた奇妙な響きも特にないので、</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>[5+3]M+ -&gt; [7+3]M- -&gt; [4+3]m- -&gt; [9+3]m-</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  S          D         t&amp;d        t&amp;s</span></code></pre></div>
<p>と分析することができる。実はこの形式の進行はポップスで多用されることで有名で、王道進行という名前があたえられていたりする。すなわち、 <code>r</code>-標準調における王道進行とは、進行</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>[5+z]M+ -&gt; [7+z]M- -&gt; [4+z]m- -&gt; [9+z]m-</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  S          D         t&amp;d        t&amp;s</span></code></pre></div>
<p>のことである。</p>
<p>総合であるが、もちろん仮に「これは王道進行である」とだけ言ってみせたとして、これでは特になにも説明したことにはならない。もうすこし詳しく見てみる必要がある。王道進行は、構造としては偽終止 <code>S -&gt; D -&gt; t</code> をさらに代理主和音 <code>t</code> で引き継ぐようなものになっている。「愛せて」のタイミングを偽終止にしておいて、ややなにかが引っかかる印象を残したうえで、それをさらにまたなにかが引っかかる印象の代理主和音 <code>[9+3]m-</code> につないでいる。これによって、まず「解決しないままに発展していく」みたいな響きが生まれている、と言えそうではある。</p>
<p>他方、王道進行の実際の響きとしてはむしろ <code>S -&gt; D</code> と <code>t&amp;d -&gt; t&amp;s</code> とがそれぞれペアになっているようにも聞こえる。これは「前半2つの和音が <code>M</code> の明るい和音で、かつ後半2つが <code>m</code> の暗い和音であることによる」と言ってもたぶんそれほど外していないと思う。今回の曲の中ではこちらの機能のほうが強く聞こえる。</p>
<p>以上を踏まえ、結局、この部分は歌詞における「美しかったか」と「愛せていたか」の対比構造を王道進行のもつ前半/後半の対比構造に重ね合わせることで、「愛せていたか」のほうの問いをより内省的に、かつ発展的に響かせているものである、と総合しておく。</p>
<p>「心の穴をみたして」について。分析としては、ベースに注目して <code>[8] -&gt; [10]</code> が拾える。奇妙な響きもないので、</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>[5+3]M+ -&gt; [7+3]M-</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  S          D</span></code></pre></div>
<p>と分析される。</p>
<p>総合としては、ここは <code>D</code> っていう本来はなにかがあとに続くはずのもので終わる形になっている。続きを予感させる形で終わっていることがわかる。</p>
<p>ところで、この部分の進行 <code>[5+3]M+ -&gt; [7+3]M-</code> は、「素朴に」やっていたらBメロの末尾にあるはずだったものでもあるわけで、そこでいったん予想を裏切って出し渋った進行をサビの最後で与えている、というふうに理解できなくもない。が、たぶんこれはすこし読みすぎだと思う。</p>
<p>まとめておく。このサビの音楽的意義は、奇妙な響き、工夫のたぐいを極力排し、なるべく素直な進行のもと、Bメロ末尾の慣性にのってボーカルのよさをまっすぐ届けるところにある。進行としてはおおむねこれまでに出現したものに王道進行を差し入れた形で、言ってみれば「普通の」やつなんだけど、けれどもこの進行が「普通」だってことそれ自体がおそらくは狙い通りのものなのであり、これが「君が待っていてもいなくても走るよ」のリラックスした美しさに繋がっている。</p>
<h4>間奏</h4>
<p>イントロと同じ。</p>
<h4>Aメロ（2）</h4>
<p>「離れるくらいなら」について。けっこう解釈のぶれそうなところではある。ベースもぐりぐりと動いている。</p>
<p>まず冒頭の5つの和音が見える箇所であるが、私はここを「1番と本質的には一緒で、ただアレンジが激しく動いているだけ」と聞く。というわけでそしてまさにその表現として、1番と同じ進行をとってみる。つまりこの部分のめまぐるしい和音の動きを <code>[5+3]M+</code> の一発で乗り切ることを考える。実際の曲と同時に鳴らしてみてみると、これが案外違和感を生じない。というわけで、まずこの5つの和音の部分については1番のままの <code>[5+3]M+</code> として分析する。</p>
<p>1番と同様であれば、続くのは <code>[7+3]M-</code> である。これはどうか。実際に鳴らしてみると、悪くない。が、2番では1番よりも2拍先にベースが <code>[0+3]</code> を鳴らしており、それゆえ <code>[7+3]M-</code> の時間は2拍短くなり、続く <code>[9+3]m-</code> が2拍長く鳴らされることになる。けっきょく、進行としては、</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>[5+3]M+ -&gt; [7+3]M -&gt; [9+3]m-</span></code></pre></div>
<p>という1番と同一の分析が得られる。総合も同様。</p>
<p>「離れるくらいなら」以降は明らかに1番と同じで、全体としてAメロの進行は1番と同一のものとして分析される。総合もまた1番と同様となる。</p>
<h4>Bメロ（2）</h4>
<p>1番と同じ。</p>
<h4>サビ（2）</h4>
<p>1番と同じ。「それだってのに」、好き。</p>
<p>ちなみに2番では王道進行のところで歌詞の対比構造が崩れている。が、それでも王道進行の力は健在で、そのせいか「思い出せるよ」と「なにがあっても」が互いに強く関係したものであるかのように響く。もし「なにがあっても」が「思い出せるよ」を修飾しているかのように聞こえたとしたら、それはたぶんこれが理由である。</p>
<h4>間奏</h4>
<p>間奏について。まずリードギターがなめらかに上行していくところを分析していく（関係ないけどこのリードギターはたいへんよい趣味をしていると思う）。ここではベースかリズムギターに注目して、まず <code>[8] -&gt; [10]</code> がとれる。同じフレーズが繰り返されて、これも <code>[8] -&gt; [10]</code> である。で、そのあとにもう一つ <code>[8] -&gt; [10]</code> がおこなわれている（最後のギターのｼﾞｬｯｼﾞｬｯｼﾞｬｯが <code>[10]</code> になっている）。というわけで、この箇所は</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>[5+3]M+ -&gt; [7+3]M- -&gt; [5+3]M+ -&gt; [7+3]M- -&gt; [5+3]M+ -&gt; [7+3]M-</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  S          D          S          D          S          D</span></code></pre></div>
<p>と分析される。</p>
<p>総合としては、ここは <code>S -&gt; D</code> を繰り返すことで明確な解決を避けるものになっている。進行のほうが停滞したままリードギターが上行していくこともあり、どことなく不思議な遊離感もある。ちなみにこの <code>S -&gt; D</code> はサビ末尾の進行そのものであり、狙っているかどうかはよくわからないが、事実としてサビを引き継ぐ形になっている。</p>
<p>続いてピアノがきらきらするところを分析していく。ここはベースもリズムギターもわかりやすくて、 <code>[0] -&gt; [7] -&gt; [10]</code> を繰り返している。つまりここは</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>[9+3]m- -&gt; [4+3]m- -&gt; [7+3]M-</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a> t&amp;s        t&amp;d         D</span></code></pre></div>
<p>の繰り返しになっている。</p>
<p>総合としては、やはりこちらも明確な終止を回避している。……なんというか、全体的に褒める感じの口調で書いてきてアレなんだけど、このピアノきらきらのところは正直あんまりよくないと思う。ギターによる間奏のほうではまだ上行っていう楽曲全体に通底するテーマにそったフレーズがみられたけれど、こっちのきらきらには特にそういうものもない。端的に言って散漫であり、なんというか「次」までの時間を埋めるためのものであるかのように聞こえる。あるいは仮にこれ自体が狙いだとして、私はそこで狙われているものはあまりよい標的ではないと思う。まあライブでやるときなんかにはネタを挟めて楽しそうではあるが。</p>
<p>なんにせよ、まとめておく。この部分の音楽的意義は、明確な終止を回避しつつ時間を経過させることにある。</p>
<h4>Cメロ</h4>
<p>Cメロについて。まず「明日明後日」から。分析としては、ここはベースに注目して <code>[5] -&gt; [7] -&gt; [8] -&gt; [10]</code> が拾えるので</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>[2+3]m- -&gt; [4+3]m- -&gt; [5+3]M+ -&gt; [7+3]M-</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  s         t&amp;d         S          D</span></code></pre></div>
<p>となり、奇妙な響きもないのでこれでよい。</p>
<p>総合としては、ここはBメロの対応部分を想起させておいたうえで <code>[8]</code> で止まらず <code>[10]</code> まで上行するという構造になっており、ここに盛り上がりが示唆されているのがおもしろいところだと思う。いつものところで考えが止まらない感じ、とでも言おうか。</p>
<p>「その先だって」について。分析としては、またベースに注目して、 <code>[0] -&gt; [2] -&gt; [3]</code> が拾える。進行としてはひとまず正則和音で</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>[9+3]m- -&gt; [11+3]d- -&gt; [0+3]M+</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a> t&amp;s         d          T</span></code></pre></div>
<p>となるのだが、ここで注目すべきは <code>[11+3]d-</code> である。ここは怪しい。そもそも一般に、正規和音における位置 <code>[11]</code> の和音があまり用いられないというのもあるし、なにより実際、「先だって」に合わせて <code>[11+3]d</code> を鳴らすと露骨に外れた響きが生じる。というわけで、ここではなんらかの別の和音が使用されていると分析するのが妥当であろう。</p>
<p>特に標準調を逸脱した音は見受けられないので、ここでは正規和音の転回形へと分析することを考える。つまり位置 <code>[11]</code> の音を含むような転回形を探していく。これについては、正規和音の音が1つおきにとられることから、位置 <code>[4], [7]</code> の和音が候補になる<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<p>というわけで、</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>[9+3]m- -&gt; ([4+3]m-)/[11+3] -&gt; [0+3]M+</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a> t&amp;s         t&amp;d                 T</span></code></pre></div>
<p>および</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>[9+3]m- -&gt; ([7+3]M+)/[11+3] -&gt; [0+3]M+</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a> t&amp;s          D                  T</span></code></pre></div>
<p>という2通りの分析可能性が得られることになる。これはまあ、どちらへと分析してもよいのではないかと思う。響きとしては、前者の <code>([4+3]m-)/[11+3]</code> はいくらかおしゃれに響いているように、また後者の <code>([7+3]M+)/[11+3]</code> はいくらかまっすぐに響いているように、それぞれ感じられる（前者が代理和音の転回形であるのに対し、後者が狭義属和音の転回形であることによると思う）。曲想としては、ここは歌詞の主体がいくらかコントロールを失うところ、おしゃれ感なんて演出してる場合じゃないよってところだと思うので、なんとなく後者へと分析したくなる。まあ好みだとは思う。</p>
<p>総合としては、これはおもしろいところで、たぶん <code>[0] -&gt; [2] -&gt; [3]</code> よりも <code>[12] -&gt; [14] -&gt; [15]</code> と書いたほうが気分に近い。つまり直前の <code>[5] -&gt; [7] -&gt; [8] -&gt; [10]</code> という上行をそのまま引き継いで上行していくような構造になっている。こみあげてくる感じというか、おさえられなくなる感じというか、そういうものに通ずる進行だと思う。</p>
<p>「追い続けた」について。分析としては、ベースに注目して <code>[5] -&gt; [7] -&gt; [8]</code> が拾える。Bメロでもみた進行で、素直な響きであり、</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>[2+3]m- -&gt; [4+3]m- -&gt; [5+3]M+</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  s         t&amp;d        S</span></code></pre></div>
<p>と分析してよい。</p>
<p>総合としては、 <code>[3]</code>-標準調において <code>[3]</code> の上が <code>[5]</code> であるという点に注目したい。つまりここの <code>[5] -&gt; [7] -&gt; [8]</code> も、最初の「明日明後日」のときのラインをもう一度演奏しているというよりは、むしろ「その先だって」での上行の最後の音 <code>[3]</code> をそのまま引き継いで上行するようなものになっている。さらに言うと、最初の「明日明後日」とはちがって今度は上行が <code>[8]</code> で止まっているというのもおもしろいと思う。ようはピークがここにあるということだろう。最高点にはすでに到達していて、もう引き返せない、あいまいにしていたはずのことがあふれて止まらない、って感じ。言語化せずにあいまいにしてきたことをいよいよ受け入れます、みたいな場ができあがる。</p>
<p>で、満を持して「君は僕の光だった」がくる。よいですね。分析としては、ベースに注目すると <code>[5] -&gt; [7] -&gt; [8] -&gt; [7]</code> になっており、ここも</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>[2+3]m- -&gt; [4+3]m- -&gt; [5+3]M+ -&gt; [4+3]m-</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  s         t&amp;d         S         t&amp;d</span></code></pre></div>
<p>でよい。特に奇妙な響きもない。</p>
<p>総合としては、ここは進行としてはたしかにBメロ末尾と一緒なんだけど、Bメロのときとはちがい、 <code>[7]</code> のタイミングでボーカルは黙るというところがポイントだと思う。 <code>[5+3]M+ -&gt; [4+3]m-</code> は緊張が弱まる進行で（音を下げるってのはそういうことだ）、この弛緩はいわばなにかを認めてしまった後のあの感覚にうまく対応している、ってところまで読むのはちょっと読みすぎかもしれないが、まあでもそう読みたくなるような条件はそろっている。</p>
<p>ついでに言うと、狙ってるのかは謎だけど（というかたぶん狙ってないんだけど）、「君は僕の光だった」がやや唐突ってところも美しいと思う。そのおかげで、段階を踏んでこういう結論になりました、って感じじゃなく、むしろ思いがけずあふれてきた言葉、ポロッと言っちゃった言葉、コントロールされていない言葉って感じが出ている。いや、もちろん、追い続けた先にある北極星みたいな光でした、って意味でいちおう繋がってはいるんだけど、「追い続けた」の後に2小節ほど時間間隔をとるメロディによってその「君」への修飾がいくらか弱いものになっていて、それによってやや唐突な印象が生まれているのが美しさに繋がっていると思う。</p>
<p>まとめておく。この曲のCメロの音楽的意義は、上行につぐ上行の果て、一番高いところで「君は僕の光だった」を歌うことにある。この機能の実現にあたり、「その先だって」の進行がその前後の上行をなめらかにつないでいるところが構造的なおもしろさになっている。螺旋階段みたいになってる。</p>
<h4>サビ（3）</h4>
<p>1番と同じ。</p>
<h4>アウトロ</h4>
<p>イントロとだいたい同じ。分析してもいいが、もう自明だろう。</p>
<h4>まとめ</h4>
<p>リラックスしたよい曲でした。ところで、以上を踏まえたうえで、あらためて<a href="https://www.youtube.com/watch?v=s7m8rALmMJY">この楽曲が採用されているエンディング</a>を参照してみると、これはなかなか学ぶところが多い。特に、表情の移り変わり、画面の移り変わりを特定の進行と比べたりするのはほとんど啓発的とさえ言ってよい。あんまりやりすぎるのもよくないだろうが。</p>
<p>たとえば、目をひく構造を持っていたあのBメロの末尾には次のような映像が与えられている<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>：</p>
<figure>
<img src="../media/5M-4m.gif" width="640" alt="よくわかる [5+3]M+ -&gt; [4+3]m- " />
<figcaption aria-hidden="true">よくわかる <code>[5+3]M+ -&gt; [4+3]m-</code><br />
</figcaption>
</figure>
<p>この表情のうつろいはホント絶妙だと思う。これが <code>[5+3]M+ -&gt; [7+3]M-</code> だったらこうはならない。よく見てほしい。これが <code>[7+3]M-</code> じゃなくて <code>[4+3]m-</code> の顔です。</p>
<p>あるいは「美しかったか 愛せていたか」に見える王道進行には次のような映像が与えられている<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>：</p>
<figure>
<img src="../media/5M-7M-4m-9m.gif" width="640" alt="よくわかる [5+3]M+ -&gt; [7+3]M- -&gt; [4+3]m- -&gt; [9+3]m- " />
<figcaption aria-hidden="true">よくわかる <code>[5+3]M+ -&gt; [7+3]M- -&gt; [4+3]m- -&gt; [9+3]m-</code><br />
</figcaption>
</figure>
<p>これもまたすぐれた表現だと思う。「美しかったか？」→ （愛せていたか？）。前半2つでは外語に注目しておいて、後半2つでは内語に注目をうつす、みたいな。 <code>M</code> の和音から <code>m</code> の和音にうつる感じとの対応というか。</p>
<p>こういうなんとなくの印象を積み重ねていって、特定の進行に自分なりのイメージをもつようにしておくと、自分で曲を書いたり、あるいは他人の曲を演奏したりするときにより多くのものが見えるようになる。その際、直前の「焦点ガ～」みたいな言語での記述ってやっぱり遅くて、不便で、上にあるような映像みたいなものを利用できるとたぶん強い。</p>
<p>それにしても、こういう画面がエンディングの中に存在しているってのは救いのある話だと思う。つまり、これらの絵を描いた人がいちいちこの曲はどういう構造で、とかって考えていたかっていうと、まあたぶんそんなことはないわけです。もちろん「たぶん」だけど。だから、なんというか、曲を書いた人間の細かな工夫みたいなものが、それを受け取った人間になにかしらの形で伝わっていることの痕跡がここにはある。誰かにそう聞いてもらえたことのしるしがある。</p>
<p>あと関係ないけど私はこのエンディングの「すぐに消えそうな一瞬はこんなにも」で毎回泣きそうになるよ。</p>
<h3>相対性理論『ミス・パラレルワールド』</h3>
<p><a href="https://www.youtube.com/watch?v=t2nTZrPQFFc">https://www.youtube.com/watch?v=t2nTZrPQFFc</a></p>
<p>ちょっと複雑になった例として、相対性理論『ミス・パラレルワールド』を調べてみる。今回は、『youthful beautiful』のときのように進行の構成からやるのではなく、あらかじめ誰かが与えた進行を調べていく。また分析・総合も、先ほどよりもサクッとやっていく。</p>
<h4>調の確定</h4>
<p>とはいえ、まあ、調くらいは自分で確定させておきましょう。冒頭のキャッチーなギターの旋律は <code>{[0], [1], [3], [5], [8], [10]}</code> から構成されている。やくしまるえつこが歌う「秘密の組織がきて」は <code>{[1], [3], [5], [6], [8]}</code> から構成されている。つまり利用可能音として <code>{[0], [1], [3], [5], [6], [8], [10]}</code> がある。距離1の音のペアとして <code>[0], [1]</code> および <code>[5], [6]</code> があり、 <code>[1] + [5] = [6]</code> なのでこの曲は <code>[1]</code>-標準調から始まる。</p>
<h4>イントロ</h4>
<p>以下では <a href="https://ja.chordwiki.org/wiki/%E3%83%9F%E3%82%B9%E3%83%BB%E3%83%91%E3%83%A9%E3%83%AC%E3%83%AB%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89">こちらの</a> サイトの解釈を調べていく。同サイトの分析によれば、イントロの進行は</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>Gb -&gt; Fm -&gt; Bbm -&gt; Gb -&gt; Fm -&gt; Bbm</span></code></pre></div>
<p>すなわち</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>[5+1]M -&gt; [4+1]m -&gt; [9+1]m -&gt; [5+1]M -&gt; [4+1]m -&gt; [9+1]m</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  S        t&amp;d       t&amp;s        S        t&amp;d       t&amp;s</span></code></pre></div>
<p>の2回の繰り返しであるという。</p>
<p>総合について。ここは通常の終止 <code>s -&gt; d -&gt; t</code> の2 * 2 = 4回の繰り返しである。ちなみに、しばらく眺めると、この部分が王道進行</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>[5+1]M+ -&gt; [7+1]M- -&gt; [4+1]m- -&gt; [9+1]M-</span></code></pre></div>
<p>における <code>[7+1]M-</code> の部分を省略して得られる進行になっていることがわかる。楽器を演奏するときはこっちで理解しておいたほうが記憶に負担がかからなくてよい、かもしれない。</p>
<p>結局、同サイトの解釈によれば、イントロは王道進行の変種の繰り返しである。</p>
<h4>Aメロ</h4>
<p>同サイトの分析によれば、Aメロ、「ひみつの組織が来て」から始まる部分の進行は</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>Ebm -&gt; Fm -&gt; Gbm -&gt; Bbm7</span></code></pre></div>
<p>すなわち</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>[2+1]m -&gt; [4+1]m -&gt; [5+1]m -&gt; [9+1]m</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  s        t&amp;d        ?        t&amp;s</span></code></pre></div>
<p>となっている。ここでおもしろいのは <code>[5+1]m</code> であろう。これは通常であれば <code>[5+1]M</code> になるところで、つまりこの和音は正規和音ではない。</p>
<p>ではこいつはいったい何物か？「調の外部への進行」の「別な標準調をとるもの」でつくった表を眺めてみると、 <code>[5]m-</code> を利用可能にするような転調が存在することがわかる。つまりこれは、慣例的に言うところのサブドミナント・マイナーであり、ここで一瞬だけ <code>[3]</code>-関係調の位置 <code>[2]</code> の和音を借りていることが分かる。つまりAメロの進行は正しくは</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>   key:[1]            key:[4]     key:[1]</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>----------------    ----------    ------</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>[2+1]m -&gt; [4+1]m -&gt; [(2+3)+1]m -&gt; [9+1]m</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  s        t&amp;d         s           t&amp;s</span></code></pre></div>
<p>となる。あるいは同じことだが、ある標準調からみたサブドミナント・マイナーを <code>Sm</code> と表記したうえで、あたかもその調における正規和音のようにみなして、</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>[2+1]m -&gt; [4+1]m -&gt; [5+1]m -&gt; [9+1]m</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  s        t&amp;d       Sm        t&amp;s</span></code></pre></div>
<p>と書いたほうがわかりやすいかもしれない。</p>
<p>総合としては、ここは <code>(s -&gt; t) -&gt; (Sm -&gt; t)</code> のように終止 <code>S -&gt; T</code> を2回繰り返すものになっている。</p>
<h4>Bメロ</h4>
<p>続けてBメロ、「放課後 ふとよぎるテレパシー」から始まる部分の進行を調べる。同サイトの分析によれば、この部分は</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>A -&gt; B -&gt; G#m -&gt; C#m -&gt; A -&gt; B -&gt; G#m -&gt; D#m</span></code></pre></div>
<p>であり、そしてここで <code>A</code> を <code>[8+1]</code> と書き直した時点で転調が起こっていることがわかる。 <code>[8]</code> は標準音階の位置ではないからである。</p>
<p>ではどういった転調が起こっているのか？ これを調べるのは簡単で、 <code>A -&gt; B</code> つまり <code>[9] -&gt; [11]</code> の部分に注目すればよい。標準調において <code>M</code> の和音が2回連続で出現する箇所は <code>[5]M, [7]M</code> のところしかないから、これによって <code>[9]</code> が位置 <code>[5]</code> の和音であることがわかる。ゆえに目的の標準調を <code>r</code> とすれば <code>r + [5] = [9]</code> となり、したがってこれは <code>[4]</code>-標準調である。</p>
<p>つまりこれは <code>[1]</code>-標準調から <code>[4]</code>-標準調への転調である。言い換えれば <code>[3]</code>-関係調への転調である。「別な標準調をとるもの」ですでに見たように、 <code>[±3]</code>-関係調への転調はしばしばおこなわれるのだった。この曲はその一例になっている。ついでに言えば、Aメロにあったサブドミナント・マイナーも <code>[3]</code>-関係調の和音であるから、この転調はすでにAメロの時点で暗示されていたとも言える。</p>
<p>というわけでこの部分の進行を <code>[4]</code>-標準調のものとしてあらためて調べてみる。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>A -&gt; B -&gt; G#m -&gt; C#m -&gt; A -&gt; B -&gt; G#m -&gt; D#m</span></code></pre></div>
<p>を書き直すと、</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>[5+4] -&gt; [7+4]m -&gt; [4+4]m -&gt; [9+4] -&gt; [5+4] -&gt; [7+4] -&gt; [4+4]m -&gt; [11+4]m</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  S        D        t&amp;d       t&amp;s       S        D       t&amp;d         ?</span></code></pre></div>
<p>となる。最後の <code>[11+4]m</code> 以外の部分については特に問題ないはずで、機能としては素直に <code>(S -&gt; D -&gt; t -&gt; t) -&gt; (S -&gt; D -&gt; t)</code> である。なお前半の <code>S -&gt; D -&gt; t -&gt; t</code> は王道進行である。後半も途中までは王道進行である。</p>
<p>問題は <code>[11+4]m</code> である。歌詞としては「東京都心は」のところで、雰囲気がはっと変わるところ。位置 <code>[11]</code> における正規和音はもちろん <code>[11]d-</code> であるから、 <code>[11+4]m</code> なんて和音は <code>[4]</code>-標準調には存在せず、それゆえここでも転調が起こっていることがわかる。</p>
<p>どこに転調するのだろうか？普通に考えれば「もとの調」であろう。転調によってつくったBメロの特殊な雰囲気を、転調をやめることで打ち切る。 <code>[11+4]m = [15]m = [2+1]m</code> なので、こう理解すればBメロの進行は</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>                         key:[4]                                  key:[1]</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>--------------------------------------------------------------    ------</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>[5+4] -&gt; [7+4]m -&gt; [4+4]m -&gt; [9+4] -&gt; [5+4] -&gt; [7+4] -&gt; [4+4]m -&gt; [2+1]m</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  S        D        t&amp;d       t&amp;s       S        D       t&amp;d        s</span></code></pre></div>
<p>と分析できる。</p>
<p>総合について。『ミス・パラレルワールド』のBメロのおもしろさは、転調の打ち切りを明示する和音 <code>[2+1]m</code> を、いわば「ほったらかし」にしているところにある。「転調をやめました！」とだけ明示して、やめたあとでどうなるかを一切語らないところにある。露骨にふわふわしたメロディから突然醒める感じ。</p>
<h4>サビ</h4>
<p>同サイトによると、サビの進行は</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>Cb -&gt; Dbsus4 -&gt; Ebm7 -&gt; Bbm</span></code></pre></div>
<p>である。すなわちこれは本稿の記法でいうところの</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>[11]M -&gt; [1]S -&gt; [3]m- -&gt; [10]m</span></code></pre></div>
<p>であるわけで、 <code>[11] = [10 + 1]</code> であり、かつ <code>[10]</code> は標準音階の位置ではないことから、これは <code>[1]</code>-標準調ではないことがわかる。つまりまた転調が起こっている。ではどこに転調しているのか。素直に <code>[4]</code>-標準調で調べてみると、</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>[7+4]M -&gt; [9+4]S -&gt; [11+4]m- -&gt; [6+4]m</span></code></pre></div>
<p>となり、前2つは問題ないが、後ろ2つが調を外れる。後ろ2つをもとの <code>[1]</code>-標準調で分析すると、</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>    key:[4]              key:[1]</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>---------------     -----------------</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>[7+4]M -&gt; [9+4]S -&gt; [2+1]m- -&gt; [9+1]m</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  D        t&amp;s        s         t&amp;s</span></code></pre></div>
<p>となって最後まで分析が通る。この曲でもそうだが、 <code>[±3]</code>-関係調への転調はわりと頻繁におこなわれるので、奇妙な和音をみつけたらまずこれらの関係調を調べてみるとよいと思う。</p>
<p>総合としてはここは <code>D -&gt; t</code> および <code>s -&gt; t</code> という2つの偽終止の組み合わせになっている。異なる調でそれぞれ終止をおこなう、という具合。</p>
<h4>まとめ</h4>
<p>『ミス・パラレルワールド』では <code>[1]</code>-標準調と <code>[4]</code>-標準調とのあいだで相互にかなり頻繁に転調がおこなわれている。ついでに言うと、ある標準調からみた <code>[±3]</code>-関係調は、ふつうの音楽理論では "parallel key" とよばれている。すなわちこの曲は、サビで「パラレルパラレル」と歌いながら2小節ごとにパラレルな調へと転調しまくるものとなっている。このあたりまで構造が見えると、たとえば「それぞれの調がそれぞれの平行世界のつもりなのかも」のような踏み込んだ読みがいくらか穏当なものになってくる。</p>
<h3>Radiohead『Pyramid Song』</h3>
<p><a href="https://www.youtube.com/watch?v=3M_Gg1xAHE4"><a href="https://www.youtube.com/watch?v=3M_Gg1xAHE4">https://www.youtube.com/watch?v=3M_Gg1xAHE4</a></a></p>
<p>だいぶ複雑になった例として、Radioheadの曲を調べてみる。もし聞いたことがないようであれば試しに聞いてみてほしい。初見だと「なに……この……なに？」となることうけあいである。拍子もわかりづらいが (いちおう (4 + 4 + 5 + 4 + 4)/16拍子とみなせばとりあえず追える)、響きも相当に特殊である。</p>
<p>この曲の歌い出し、0:43~の「I jumped in the river and what did I see? / Black-eyed angels swam with me」について調べてみる。</p>
<p>『ミス・パラレルワールド』のときと同様、検索して出てきた<a href="https://tabs.ultimate-guitar.com/tab/radiohead/pyramid-song-chords-401528">サイト</a>の進行を調べていく。曰く、同サイトによれば、この箇所は次のように進行しているという：</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>  F#                  Gmaj7        A6        Gmaj7   F#</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>I jumped in the river and what did I see?</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>F#m          Eadd9                Gmaj7</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>Black-eyed angels swam with me</span></code></pre></div>
<p>本稿の記法に落として進行を書くとこれは次のようになる：</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>[6]M -&gt; [7]M+ -&gt; [9]M -&gt; [7]M+ -&gt; [6]M -&gt; [6]m -&gt; [4]M -&gt; [7]M</span></code></pre></div>
<p>ここで <code>A6</code> の <code>6</code>, および <code>Eadd9</code> の <code>add9</code> 部分は無視した（和音としての機能はたいして変わらないので）。</p>
<p>さて調を確定したいのだが、まずもって冒頭3つの <code>[6]M -&gt; [7]M+ -&gt; [9]M</code> の時点でこれはもう完全に異常である。 <code>M</code> の和音が3連続しているわけであり、まあ、謎である。</p>
<p>ここで参考になるのは <code>[7]M+</code> と <code>[6]M</code> の関係である。「別な標準調をとるもの」のところで書いた図を参考にすると、標準調において、 <code>M</code> の和音の1だけ上に <code>M+</code> な和音を配置できるような手法が存在することがわかる。つまり、ナポリの六度である。ナポリの六度は位置 <code>[1]</code> で <code>M+</code> の和音を利用する手法であった。というわけで、 <code>[7]M+</code> がこのナポリの六度であると仮定して分析を始めていく。</p>
<p><code>[7]M+</code> がナポリの六度であるなら、この曲は <code>[6]</code>-標準調であるということになる。ここまでで、上記を</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>    key:[6]             ?           key:[6]           ?          ?       key:[6]</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>-----------------    ------    -----------------    ------    -------    ------</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>[0+6]M -&gt; [1+6]M+ -&gt; [3+6]M -&gt; [1+6]M+ -&gt; [0+6]M -&gt; [0+6]m -&gt; [10+6]M -&gt; [1+6]M</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>            N                    N                                         N</span></code></pre></div>
<p>まで分析することができる。ここで「 <code>N</code> 」はナポリの六度を明示するための記号である。</p>
<p>次に <code>[3+6]M</code> に説明を与えたい。さきほどの図をみれば分かる通り、位置 <code>[3]</code> に典型的な和音は存在しない。</p>
<p>では <code>[±3]</code>-関係調への転調を考えてみるとどうか。 <code>[6]</code>-標準調の <code>[±3]</code>-関係調は <code>[3]</code>-標準調、および <code>[9]</code>-標準調である。 <code>[3+6] = [9] = [6+3] = [0+9]</code> であるから、 <code>[9]M</code> を説明できるのは <code>[9]</code>-標準調のほうである。こちらで調べると、問題の進行は</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>    key:[6]          key:[9]           key:[6]           key:[9]        key:[6]</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>-----------------    ------    -----------------    -----------------   ------</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>[0+6]M -&gt; [1+6]M+ -&gt; [0+9]M -&gt; [1+6]M+ -&gt; [0+6]M -&gt; [9+9]m -&gt; [7+9]M -&gt; [1+6]M</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>            N                    N                                        N</span></code></pre></div>
<p>ここまで分析することができる。</p>
<p>一通り進行を分析することができたわけだが、ここには注目するべき構造がまだある。つまり、 <code>[0+6]M = [6]M</code> と <code>[9+9]m = [6]m</code> との関係である。</p>
<p><code>[6]M = [9+9]M</code> なので、 <code>[9]</code>-標準調を基準にして考えれば、この進行における冒頭の <code>[0+6]M</code> は <code>[9+9]M</code> ということでもある。つまり冒頭の和音は、 <code>[9]</code>-標準調の位置 <code>[9]</code> における <code>M</code> の和音である。これはさきほどの図をみればわかるが、いわゆるピカルディの三度になっている：</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>    key:[6]          key:[9]           key:[6]           key:[9]        key:[6]</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>-----------------    ------    -----------------    -----------------   ------</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>[0+6]M -&gt; [1+6]M+ -&gt; [0+9]M -&gt; [1+6]M+ -&gt; [0+6]M -&gt; [9+9]m -&gt; [7+9]M -&gt; [1+6]M</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>  ↑         N                    N          ↑         |                   N</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>  |                                         |         |</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>   ---------------------------------------------------</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>                        P</span></code></pre></div>
<p>通常、ピカルディの三度は <code>[9]m</code> がくることを予想させたうえでそれを裏切って <code>[9]M</code> を利用する、という形で用いられる。わかりやすい例としてはショパンの夜想曲第15番がある：</p>
<p><a href="https://www.youtube.com/watch?v=99QJM9Gunvg">https://www.youtube.com/watch?v=99QJM9Gunvg</a></p>
<p>4:30から続けて3つの和音が演奏されるが、ここで3番目の和音にある明るさがピカルディの三度の色である。 <code>[9]m</code> がくるべき場所に <code>[9]M</code> を用いることである特有の雰囲気をもった明るさが実現されている。一条の光、みたいな。</p>
<p>他方、『Pyramid Song』では逆に、 <code>[9]M</code> を先に提示したうえで <code>[9]m</code> が与えられている。すなわちここには「逆方向のピカルディの三度」とでも呼ぶべき構造があり、これによって特有の雰囲気をもった暗さが作り出されている。改めて "Black-eyed angels" の箇所にある特有の暗さを味わってみてもらえれば、なるほどなんとなくピカルディの逆っぽい、と看取できるのではないかと思う。暗く脱力するというか。</p>
<p>簡単にまとめるなら、『Pyramid Song』の進行はナポリの六度を基準にしてゆるやかに振動している。そしてこの振動の上端と下端に近づくたびに <code>[3]</code>-関係調へと転調してそちらの和音をもとの標準調の和音であるかのように利用する、という構造になっている。さらにここにナポリの六度とか逆向きのピカルディとかの響きが絡み合って上にあるような独特の雰囲気が構成されている。</p>
<h2>跋</h2>
<p>まあ自由にやっていきましょう。</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>通常はこの和音による終止のことをピカルディの三度とよぶが、まあ和音に名前をあたえたほうがあつかいやすい。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>ここでは3和音で考えている。和音の構成音は、あまり少なすぎても必要な転回形が見つからず、またあまり多すぎても和音の響きが濁ってしまうので（12和音とはすなわち鍵盤全部を同時に叩いて得られる音である）、3和音または4和音くらいで考えるのが穏当だと思う。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>TRIGGER, 『<a href="https://gridman.net/">SSSS.GRIDMAN</a>』, 「GRIDMAN」製作委員会, 2018.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>TRIGGER, 『<a href="https://gridman.net/">SSSS.GRIDMAN</a>』, 「GRIDMAN」製作委員会, 2018.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Executing Types</title>
    <link href="https://vekatze.github.io/post/2020-10-17.html" />
    <id>https://vekatze.github.io/post/2020-10-17.html</id>
    <published>2020-10-17</published>
    <updated>2020-10-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<header>
    <h1>Executing Types</h1>
    
    <span class="metadata">2020-10-17</span>
    
</header>

<p>I was looking for a language that satisfies all of the following:</p>
<ol>
<li>Its type system is static and strong enough<br />
</li>
<li>It corresponds to the ordinary lambda calculus<br />
</li>
<li>Its memory management is determined at compile-time</li>
</ol>
<p>Such a thing can't be found easily, of course. The third condition is notably problematic. If we consider only the first two, we immediately reach our happy ending by simply holding hands with garbage collection. I'll be in a peaceful life with OCaml, Haskell, or F# in this case. When we consider the third one, however, the plot gets twisted.</p>
<p>In the end, <a href="https://github.com/u2zv1wx/neut">I implemented such a language by myself</a>. A dependently-typed programming language with static memory managemement that doesn't rely on additional annotations to its type system. It seemed to me that the method that I found to pass the third condition was interesting by itself, and that's why I decided to introduce it in this article.</p>
<p>Getting straight to the point, the method is something that "executes types." Or, more specifically, the method converts a type into a function that copies / discards the values of the type. I emphasize here that I do love all of the GC-based approaches, the region-based approaches, and the manual approach that we see in C. All of them in their own ways. Be that as it may, I think the approach that I present in this article is interesting as a possibility.</p>
<p>Some notes:</p>
<ul>
<li>This article doesn't contain any safety guarantees. Obviously I agree that those guarantees would make this article 100 times better. This omission is simply due to my limited resource. I suggest you take this article as an implication or something like that, with a grain of salt.<br />
</li>
<li>I chose to write the motivation and the background in the appendix; The main part focuses on describing the point of the method as quickly as possible. You can visit the appendix to fully enjoy the virtue of the method.<br />
</li>
<li>This article should be read by anyone who knows OCaml, Haskell, or a language that is similar to them. If it isn't, it's simply my fault.</li>
</ul>
<p>Let's move on to the main part. It starts by constructing a small language with desirable properties.</p>
<h2 data-toc=":include siblings :depth 2 :ignore (this)" id="toc">Index</h2>
<div class="CONTENTS drawer">
<ol>
<li><a href="#exploiting-the-power-of-linearity">Exploiting the power of linearity</a>
<ol>
<li><a href="#a-language-that-uses-every-variable-just-once">A language that uses every variable just once</a><br />
</li>
<li><a href="#resource-management-under-linearity">Resource management under linearity</a><br />
</li>
<li><a href="#smuggling-non-linearity">Smuggling non-linearity</a><br />
</li>
</ol></li>
<li><a href="#executing-types">Executing Types</a>
<ol>
<li><a href="#finding-vocabulary-for-resource-management-in-the-target-language">Finding vocabulary for resource management in the target language</a><br />
</li>
<li><a href="#how-types-are-translated-more-concretely">How types are translated, more concretely</a><br />
</li>
<li><a href="#how-translated-types-are-utilized">How translated types are utilized</a><br />
</li>
<li><a href="#a-short-break-at-the-end">A short break at the end</a><br />
</li>
</ol></li>
<li><a href="#appendix">Appendix</a>
<ol>
<li><a href="#a-highly-accelerated-introduction-to-natural-deduction">A highly-accelerated introduction to natural deduction</a><br />
</li>
<li><a href="#motivation-from-proof-theory-or-the-ice-cold-correspondence">Motivation from proof theory, or the ice-cold correspondence</a><br />
</li>
<li><a href="#computational-significance-of-local-completeness">Computational significance of local completeness</a><br />
</li>
<li><a href="#a-foundation-for-the-resource-management-via-copydiscard">A foundation for the resource management via copy/discard</a><br />
</li>
<li><a href="#can-we-expect-acceptable-performance-from-this-approach">Can we expect acceptable performance from this approach?</a><br />
</li>
<li><a href="#miscellaneous">Miscellaneous</a><br />
</li>
</ol></li>
<li><a href="#afterword">Afterword</a></li>
</ol>
</div>
<h2>Exploiting the power of linearity</h2>
<h3>A language that uses every variable just once</h3>
<p>It would be a straightforward idea to think about a simpler language before we dive into a fully-equipped one. Let's take that way here, too.</p>
<p>We can restrict a programming language in various ways. Here, we add a restriction on the use of variables. More specifically, we consider a programming language like OCaml or Haskell, with the following additional property: every variable is used exactly once. Such a use of a variable is called to be "linear."</p>
<p>Let's call our language L<sup>-</sup>. The next pseudo-code, for example, should be valid in L<sup>-</sup>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>let y := 1 in</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>add x y</span></code></pre></div>
<p>Note that both of the variables <code>x</code> and <code>y</code> are used linearly. On the other hand, the following pseudo-code should be invalid:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>add x x</span></code></pre></div>
<p>This is because the variable <code>x</code> is used twice in <code>add x x</code>. Also, the next code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>10</span></code></pre></div>
<p>should be invalid since the variable <code>x</code> is not used. Or, assuming that a function <code>increment</code> is defined beforehand, the next pseudo-code should be invalid, again:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>let y := increment x in</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>add x y</span></code></pre></div>
<p>We can easily check that the variable <code>x</code> is used twice in total (<code>increment x</code> and <code>add x y</code>). The <code>x</code> is already consumed at <code>increment x</code>, and thus we can no longer use it at the point of <code>add x y</code>, so to speak.</p>
<p>Of course, imposing linearity to every variable is really a demanding restriction. We won't be able to write a real program in a language with such a restriction. We will, however, see how this restriction can be bypassed soon, so we don't have to worry about the problem of expressivity now.</p>
<h3>Resource management under linearity</h3>
<p>Here we assume that the language L<sup>-</sup> consists of variables, lambda-abstractions, function applications, and <code>let</code>. We omit arrays like <code>[1, 2, 3]</code>, or integers like <code>100</code> that we see above. This is because what we see below can be applied essentially as it is to those omitted constructs; We omit them so as not to make the text needlessly long.</p>
<p>Let's think about realizing static resource management in our language L<sup>-</sup>. Then we can easily find the following immediate solution.</p>
<p>We allocate memory when and only when we process lambda-abstraction. For example, let's consider the following code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>let f := λ y. (some computation) in</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>(remaining computation)</span></code></pre></div>
<p>The code should behave as follows:</p>
<ol>
<li>Allocates a piece of memory to express <code>λ y. (some computation)</code>,<br />
</li>
<li>Writes information of the lambda-abstraction (this information is represented by a tuple like <code>(info-1, ..., info-n)</code>, and referred to as "closure"),<br />
</li>
<li>Binds a pointer to the region to <code>f</code>,<br />
</li>
<li>Executes <code>(remaining computation)</code>.<br />
</li>
</ol>
<p>This behavior shouldn't be much different than that of an ordinary language.</p>
<p>On the other hand, we deallocate memory when and only when we process function application. For example, let's consider the following code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(some computation) in</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>f a</span></code></pre></div>
<p>The code should behave as follows:</p>
<ol>
<li>Executes <code>(some computation)</code>,<br />
</li>
<li>Extracts <code>info-1</code>, …, <code>info-n</code> from the variable <code>f</code>,<br />
</li>
<li>Deallocates the tuple <code>(info-1, ..., info-n)</code>,<br />
</li>
<li>Calls the appropriate function with <code>a</code> as its argument.</li>
</ol>
<p>The memory management defined above is safe. It also deallocates all the resources that are allocated during program execution. This is thanks to of the linearity of the language; Firstly, by the linearity, every lambda-abstraction is used exactly once. This means, of course, that every lambda-abstraction is used at most once, and at least once. Since they are used (applied) at most once, a lambda abstraction is deallocated at most once. This guarantees the property "a deallocated resource won't be deallocated again." Also, since they are used (applied) at least once, a lambda abstraction is deallocated at least once. This guarantees the property "every lambda abstraction is deallocated."</p>
<p>All in all, the language L<sup>-</sup> can realize static memory management by the interpretation above. The language already has our desired property. In the next section, we look for a way to enhance the expressivity of this language, keeping the charming property intact.</p>
<h3>Smuggling non-linearity</h3>
<p>We need loopholes against linearity, and nothing prevents us from injecting them into our language. Let's add the constants below for any type <code>A</code>:</p>
<ul>
<li><code>copy_A : A -&gt; A * A</code><br />
</li>
<li><code>discard_A : A -&gt; top</code></li>
</ul>
<p>Here, the <code>A * A</code> is the type of a pair that consists of two values of type <code>A</code>. The <code>top</code> is so-called unit type. A little thought makes us realize that these constants can be used to bypass the restriction of linearity. Consider the following invalid code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>let x := 1 in</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>add x (add x x)</span></code></pre></div>
<p>The code above can be rewritten using those constants:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>let x := 1 in</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>let (x1, tmp) := copy_int x in</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>let (x2, x3) := copy_int tmp in</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>let (add1, add2) := copy_(int-&gt;int-&gt;int) add in</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>add1 x1 (add2 x2 x3)</span></code></pre></div>
<p>The code is now valid as a code in the language L<sup>-</sup>. Or, consider the following:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>10</span></code></pre></div>
<p>Similarly, this can be rewritten as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>let () := discard_int x in</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>10</span></code></pre></div>
<p>In both cases, the resulting code uses every variable lineary thanks to <code>copy</code> or <code>discard</code>. More generally, if a variable <code>x</code> of type <code>A</code> is used for n times,</p>
<ul>
<li>if n &lt; 1, we can use <code>discard_A</code> to make the use of <code>x</code> linear.<br />
</li>
<li>if n = 1, the use of <code>x</code> is already linear.<br />
</li>
<li>if n &gt; 1, we can use <code>copy_A</code> to make the use of <code>x</code> linear.</li>
</ul>
<p>This recovers the expressivity that once was diminished by the imposition of linearity. Also, since we didn't touch the behavior of the language, only these constants are peculiar from the viewpoint of resource management. Thus now we just have to consider how these constants can be realized using other language constructs, assuming that it is possible<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<h2>Executing Types</h2>
<p>As quickly mentioned in the preface, we can use types to realize static resource management, or to implement those constants. In this section, firstly we see the basic idea of how to utilize a type for resource management. Next, we see how various types are translated to realize <code>copy_A</code> and <code>discard_A</code> under the idea. Finally, we see how those results of the translation are utilized.</p>
<h3>Finding vocabulary for resource management in the target language</h3>
<p>Let's see the basic idea by an example. Consider we have a term <code>e</code> of type <code>A * B</code>. In this situation, we can expand <code>e</code> as follows, without knowing the internal construction of <code>e</code> is:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>let (x, y) := e in (x, y)</span></code></pre></div>
<p>Such a expansion is often referred to as an η-expansion. This operation keeps the meaning of a term (as long as the <code>e</code> doesn't contain any effects):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>   let (x, y) := (&quot;foo&quot;, (3, true)) in (x, y)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>~&gt; (&quot;foo&quot;, (3, true))</span></code></pre></div>
<p>Now, the point here is that we can perform this expansion to <code>e</code> by knowing only the type of <code>e</code>. We don't have to care about how <code>e</code> is actually constructed. This means that we can turn the operation of η-expansion for <code>A * B</code> into a function:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  (x, y)</span></code></pre></div>
<p>The virtue of this function is that it allows us to inspect the internal structure of <code>e</code> by using the variables <code>x</code> and <code>y</code>. It allows us to trace the content of <code>e</code>. Now, using this η-expansion as a reference, let's suppose that we can define a translation <code>Expand(_)</code> that turns a type into a function that traces the terms of the type. <code>Expand(A * B)</code> should be something like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  let x&#39; := Expand(A) x in</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  let y&#39; := Expand(B) y in</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  (x&#39;, y&#39;)</span></code></pre></div>
<p>If we can define this <code>Expand(_)</code> to other types, we should be able to trace every term recursively.</p>
<p>Of course, even if we can define such <code>Expand(_)</code>, it doesn't mean that we can copy/discard resources. It only means that we can now propagate η-expansion to a term, so to speak. The problem of copy/discard is, however, almost solved already. For example, let's suppose that we can define a translation <code>Copy(_)</code> that turns a type into the corresponding "copy" function of the type. Now we can define <code>Copy(A * B)</code> as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  let (x1, x2) := Copy(A) x in</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  let (y1, y2) := Copy(B) y in</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  ((x1, y1), (x2, y2))</span></code></pre></div>
<p>This function is indeed of type <code>A * B -&gt; (A * B) * (A * B)</code>. Or, let's suppose that we can define a translation <code>Discard(_)</code> that turns a type into the corresponding "discard" function. Again, <code>Discard(A * B)</code> can be defined as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  let () := Discard(A) x in</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  let () := Discard(B) y in</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  ()</span></code></pre></div>
<p>This function is of type <code>A * B -&gt; top</code>.</p>
<p>After all, the core idea is to implement <code>copy_A</code> and <code>discard_A</code> by extending the functionalized η-expansion into "the power of n". To give such a computational interpretation to types. To translate a type <code>A</code> into the pair <code>(copy_A, discard_A)</code> and extract the required element from this pair and use it to turn a non-linear code into a linear one. The repository that we see in the preface is an implementation of this idea.</p>
<p>Incidentally, in its actual implementation, a type <code>A</code> is translated into not the pair of <code>copy_A</code> and <code>discard_A</code>, but the following 2-ary function <code>exp_A</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>λ flag z.</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  if flag</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  then discard_A z</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  else copy_A z</span></code></pre></div>
<p>This <code>exp_A</code> is used as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>-- to discard x : A</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>let () := exp_A true x in</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>-- to copy x : A</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>let (x1, x2) := exp_A false x in</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>(...)</span></code></pre></div>
<p>This is just an implementation-level optimization. This isn't expressivity-related stuff. By adopting this, a type is translated into a closed function, not a pair. Since a closed function is represented as a simple function pointer, it can be copied/discarded just in the same way as an immediate value like an integer. Thus we can copy/discard the result of the translation of a type as if it were an integer. This omits tedious allocations/deallocations that would've been necessary if we had taken the other approach. Our approach is also preferable from the viewpoint of performance. That's why I chose this approach in the actual implementation.</p>
<h3>How types are translated, more concretely</h3>
<p>Here, we see how <code>copy</code> and <code>discard</code> are defined for various types.</p>
<h4>Immediate</h4>
<p>On immediate types like <code>int</code>. We can define <code>copy</code> and <code>discard</code> for them as follows:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>let copy_int :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  λ x. (x, x)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>let discard_int :=</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  λ x. ()</span></code></pre></div>
<p>Since the argument of <code>copy_int</code> and <code>discard_int</code> are immediate, it can be copied/discarded without any memory operations. Thus we can use the argument in non-linear manner. The allocating operation for <code>(x, x)</code> is the only memory-related operation in these functions.</p>
<h4>Array</h4>
<p>On array types like <code>int[3]</code> (Here we assume that every value of an array is immediate). We can define <code>copy</code> and <code>discard</code> as follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>let copy_int_3 :=</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  λ x.</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    let [a, b, c] := x in</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    ([a, b, c], [a, b, c])</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>let discard_int_3 :=</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  λ x.</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    let [a, b, c] := x in</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    ()</span></code></pre></div>
<p>That is, we can extract values from <code>x</code> and then construct a new array. Here, the meaning of</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>let [a, b, c] := x in (...)</span></code></pre></div>
<p>is assumed to be something like this:</p>
<ol>
<li>binds all the elements to <code>a</code>, <code>b</code>, and <code>c</code>,<br />
</li>
<li>deallocates the array <code>x</code>.<br />
</li>
</ol>
<p>Thus, the behavior of <code>copy</code> is, for example, as follows:</p>
<ol>
<li>binds all the elements of <code>x</code> to <code>a</code>, <code>b</code>, and <code>c</code><br />
</li>
<li>deallocates <code>x</code><br />
</li>
<li>allocates a piece of memory for <code>[a, b, c]</code> (the first time)<br />
</li>
<li>writes <code>[a, b, c]</code> to the memory region (the first time)<br />
</li>
<li>allocates a piece of memory for <code>[a, b, c]</code> (the second time)<br />
</li>
<li>writes <code>[a, b, c]</code> to the memory region (the second time)<br />
</li>
<li>allocates a piece of memory for <code>([a, b, c], [a, b, c])</code><br />
</li>
<li>writes <code>([a, b, c], [a, b, c])</code> to the memory region<br />
</li>
</ol>
<p>Note that we can copy <code>a</code>, <code>b</code>, and <code>c</code> without any additional operations since they are immediate.</p>
<h4>Type of Types</h4>
<p>The <code>Type</code> in <code>A : Type</code> is also a type, and thus it is something to be translated. It can be, however, treated in the same way as an immediate thanks to the optimization that we've seen. Thus, we can define the <code>copy</code> and <code>discard</code> for the type of types simply as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>let copy_type :=</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  λ x. (x, x)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>let discard_type :=</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  λ x. ()</span></code></pre></div>
<h4>Function</h4>
<p>On function types like <code>int -&gt; bool</code>. This is a little complicated. You might want to skip this if you just want to catch the general drift. Anyway, we need to see how a lambda-abstraction is translated to explain the behavior of a function type. Consider the following code.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>let f :=</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  let b := true in</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  let y := 10 in</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  λ x. x + (as-int b) + y in</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>(...)</span></code></pre></div>
<p>Here, <code>as-int</code> is a function that (for example) translates <code>true</code> to <code>1</code>, and <code>false</code> to <code>0</code>, respectively.</p>
<p>The code above contains a lambda abstraction <code>λ x. x + (as-int b) + y</code> that has <code>b : bool</code> and <code>y : int</code> as its free variables. In an ordinary programming language, such a lambda-abstraction is translated into the following pair:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>((b, y),</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  λ (x, env).</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    let (b, y) := env in</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    x + (as-int b) + y)</span></code></pre></div>
<p>That is, a pair of the following form:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>({the set of all the free variables},</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a> λ ({the original arguments}, env).</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>   let (the names of the free variables) := env in</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>   {the original code})</span></code></pre></div>
<p>This translation is referred to as closure conversion. In our system, we extend this procedure; We translate the lambda abstraction into the following 3-tuple:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(bool * int,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a> (b, y),</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  λ (x, env).</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    let (b, y) := env in</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    x + (as-int b) + y)</span></code></pre></div>
<p>That is, we attach the type information of the free variables<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. With this information, we can easily copy/discard a closure. Indeed, for every element of a closure,</p>
<ul>
<li><code>bool * int</code> can be copied/discarded as an immediate since it is a type.<br />
</li>
<li><code>(b, y)</code> can be copied/discarded using <code>bool * int</code>.<br />
</li>
<li>the third element can be copied/discarded as an immediate since it is a function pointer to a closed function.<br />
</li>
</ul>
<p>This realizes the <code>copy</code> and <code>discard</code> of a closure<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>After all, the <code>copy</code> and <code>discard</code> for a function type like <code>int -&gt; bool</code> are defined as follows:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>let copy_closure :=</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  λ cls.</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    let (env_type, env, func) := cls in</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    let (env1, env2) := env_type false env in</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    ((env_type, env1, func), (env_type, env2, func))</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>let discard_closure :=</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  λ cls.</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    let (env_type, env, func) := cls in</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    let () := env_type true env in</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    ()</span></code></pre></div>
<p>Here, the behavior of</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>let (x1, ..., xn) := x in (...)</span></code></pre></div>
<p>is assumed to be something like:</p>
<ol>
<li>binds all the elements of <code>x</code> to <code>x1</code>, …, <code>xn</code>,<br />
</li>
<li>deallocates <code>x</code></li>
</ol>
<h3>How translated types are utilized</h3>
<p>Finally, let's see how these results of the translation are utilized to linearize given code. Consider the following function:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>let to-pair :=</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  λ (A : Type) (x : A). (x, x)</span></code></pre></div>
<p>This function <code>to-pair</code> is something that is used in the following way:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>to-pair int         3              # ~&gt; (3, 3)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>to-pair string      &quot;hello&quot;        # ~&gt; (&quot;hello&quot;, &quot;hello&quot;)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>to-pair (bool * top) (false, unit) # ~&gt; ((false, unit), (false, unit))</span></code></pre></div>
<p><code>to-pair</code> is a polymorphic function that creates the pair of the given argument.</p>
<p>As you can see, the variable <code>x</code> is used twice in the definition of <code>to-pair</code>. This non-linear <code>x</code> is linearized using <code>A</code> essentially as follows:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>let to-pair :=</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  λ A x.</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    let (x1, x2) := A false x in</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    (x1, x2)</span></code></pre></div>
<p>The function <code>to-pair</code> receives various kinds of values at the position of <code>x</code>. It can, however, copy the value <code>x</code> since the accompanying argument <code>A</code> necessarily contains the required information to copy the value. The same applies to <code>discard</code>.</p>
<h3>A short break at the end</h3>
<p>The above concludes the main part of this article. We see how static memory management is realized by executing types. In a highly sketchy manner, admittedly.</p>
<p>I believe that you can now guess why I chose to use dependent type theory in this attempt; The theory just simplifies the implementation since a type in the theory occurs in a program just in the same way as a term.</p>
<p>Incidentally, I've seen a lot of introductory articles that support the usefulness of dependent type theory by emphasizing the possibility of length-annotated array types. Such a type can be used to realize array accessing in a safe way. Yes, that's completely true. At the same time, however, I'd like to emphasize another virtue of such a theory here. That is, it makes the language more integrated: Both of the type-level abstraction (i.e. <code>forall</code>) and the term-level abstraction (i.e. function) are represented by the same syntax construct (i.e. <code>λ</code>). We don't need an additional concept to, for example, define a type. This property can be something that appeals to those who seek for a theoretical virtue.</p>
<p>Also, I'll add a note here. I'm writing this article, thinking that the method that I've shown in this article is new (to some degree). As a general rule, however, there is often a more thoughtful person who has already investigated the very thing that I think is new, and the investigation is often more sophisticated than mine. If it is the case, I hope that this article works as a useful annotation to the preceding research.</p>
<p>Anyway, the main part ends here. Reading the additional contents below should make the main part more attractive, like a fighting game with a basic understanding of the theory behind it. Let's go ahead.</p>
<h2>Appendix</h2>
<h3>A highly-accelerated introduction to natural deduction</h3>
<p>I tried to omit this section at first, but it turned out to be essential for the explanation. That's why I write a highly-accelerated introduction to the natural deduction. If you want to read a more thorough introductory article, I think you can refer to <a href="https://www.cs.cmu.edu/~fp/courses/15317-f09/schedule.html">the lecture notes by Pfenning</a>. Many thanks to the author and Carnegie Mellon University.</p>
<h4>Encounter with propositional logic</h4>
<p>Let's fix a set of distinct symbols. We call an element of this set a propositional variable. We also assume that there are infinitary many propositional variables (the number of them is assumed to be exactly the same as that of the natural numbers). We then define "proposition" as follows:</p>
<ol>
<li>If <span class="math inline">\( \alpha \)</span> is a propositional variable, then <span class="math inline">\( \alpha \)</span> is a proposition.<br />
</li>
<li>If <span class="math inline">\( A, B \)</span> are propositions, then <span class="math inline">\( A \to B \)</span> is a proposition.<br />
</li>
<li>No other syntactic construct is a proposition.<br />
</li>
</ol>
<p>For example, if <span class="math inline">\( P \)</span>, <span class="math inline">\( Q \)</span>, and <span class="math inline">\( R \)</span> are propositional variables, then all of <span class="math inline">\( P \)</span>, <span class="math inline">\( P \to Q \)</span>, <span class="math inline">\( P \to (Q \to R) \)</span> and <span class="math inline">\( (P \to P) \to R \)</span> are propositions.</p>
<p>You may now think that "What are those parentheses in <span class="math inline">\( P \to (Q \to R) \)</span>?" It's actually not that important, but I'll answer this question here just in case. These parentheses are required because, if we simply write <span class="math inline">\( P \to Q \to R \)</span>, we don't know how to tell if it represents this tree:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    →</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  →   R</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>P   Q</span></code></pre></div>
<p>or this tree:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  →</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>P   →</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  Q   R</span></code></pre></div>
<p>The parentheses here are meta-level entities that allow us to represent a tree-structure in a sentence. Indeed, we don't need them if we write a tree structure every time we need it, but it'll be tedious and space-demanding. To summarize:</p>
<ol>
<li>The "<span class="math inline">\( A \to B \)</span>" in "<span class="math inline">\( A \to B \)</span> is a proposition" is not a character sequence but a tree structure<br />
</li>
<li>Writing a tree structure every time is troublesome<br />
</li>
<li>By the way, we can use parentheses to represent a tree structure in a sentence<br />
</li>
<li>Then let's use it as a useful abbreviation<br />
</li>
</ol>
<p>Using parentheses is a simple trick to represent a tree structure.</p>
<p>Also, one might think that the last condition "No other syntactic construct is a proposition" is peculiar. This is, again, not so complex. This is just to say "no" when we're asked like, for example, "Then, is <span class="math inline">\( \uparrow \uparrow \downarrow \downarrow \leftarrow \to \leftarrow \to  A B\)</span> a proposition?" Without the last condition, we don't know what is not a proposition.</p>
<p>Next, we define "quasi-context" as follows.</p>
<ol>
<li><span class="math inline">\( \cdot \)</span> is a quasi-context.<br />
</li>
<li>If <span class="math inline">\( \Gamma \)</span> is a quasi-context and <span class="math inline">\( A \)</span> is a proposition, then <span class="math inline">\( \Gamma, A \)</span> is a quasi-context.<br />
</li>
<li>No other syntactic construct is a quasi-context.<br />
</li>
</ol>
<p>In short, a quasi-context is a list of propositions. Something like <span class="math inline">\( \cdot, A, B, C \)</span>. Or, more explicitly, a tree structure like:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>      ,</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>     / \</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    ,   C</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  ,   B</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>.   A</span></code></pre></div>
<p>We don't need any parentheses this time because we don't have a tree of the following form, for example:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  ,   C</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>A   ,</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  .   B</span></code></pre></div>
<p>In other words, that's because it suffices to say that "it is a quasi-context" to specify the tree structure of <span class="math inline">\( \cdot, A, B, C \)</span>.</p>
<p>We call <span class="math inline">\( \cdot \)</span> an empty quasi-context. As you can see from the example above, a non-empty quasi-context is of the form <span class="math inline">\( \cdot, A_1, \ldots, A_n \)</span>. Such a quasi-context is often written as <span class="math inline">\( A_1, \ldots, A_n \)</span>, omitting the <span class="math inline">\( \cdot \)</span>.</p>
<p>We define a context to be a quasi-context without order. For example, <span class="math inline">\( A, B, C, C \)</span> and <span class="math inline">\( C, B, A, C \)</span> are different when seen as quasi-contexts, but the same when seen as contexts.</p>
<p>Let's define a judgment as follows.</p>
<ol>
<li>If <span class="math inline">\( \Gamma \)</span> is a context and <span class="math inline">\( A \)</span> is a proposition, then <span class="math inline">\( \Gamma \vdash A \)</span> is a judgement.<br />
</li>
<li>No other syntactic construct is a judgment.<br />
</li>
</ol>
<p>For example, all of <span class="math inline">\( A \vdash A \)</span>, <span class="math inline">\( C \vdash A \to (B \to B) \)</span>, and <span class="math inline">\( \Gamma \vdash A \)</span> are judgement.</p>
<p>Our "judgment" is, despite its suggestive name, currently just a syntactic construct with a certain pattern. Just a tree structure with a mysterious name. We'd like to reach the point where we can interpret <span class="math inline">\( \Gamma \vdash A \)</span> as "Assuming <span class="math inline">\( \Gamma \)</span>, <span class="math inline">\( A \)</span> is true." We don't, however, have any frameworks that allow us to interpret our judgments.</p>
<p>So let's construct such a framework. A framework that allows us to say "This judgment is correct," or "not correct." We're going to, roughly speaking, define a framework to talk about the meaning of a judgment.</p>
<p>Generally speaking, there are basically two approaches to define the meaning of a symbol.</p>
<ol>
<li>The internal approach. In this approach, we define what a symbol refers to. This approach relates the symbol "that apple" to that red object on that table. This is an approach that focuses on the internals of a symbol, so to speak. If the referred object (= meaning) is defined, we can say that the referred object (= meaning) is not correct when, for example, the symbol "that apple" is used to refer to the Tale of Genji.<br />
</li>
<li>The external approach. In this approach, we define how a symbol is used. The approach relates the symbol "that apple" to the use of it like "to turn the attention of the listener to that red object on that table." This is an approach that focuses on the behavior of a symbol, so to speak. If the use (= meaning) is defined, we can say that the use (= meaning) is not correct when, for example, the listener starts headbanging as soon as the person perceived the utterance "that apple."</li>
</ol>
<p>We'll take the latter approach here. Using a few rules, we'll define how a symbol that we named a "judgment" is used. Such a rule is called as an inference rule.</p>
<p>An inference rule is represented in the following form:</p>
<p><span class="math display">\[
\require{bussproofs}
\begin{prooftree}
  \AxiomC{\( \mathcal{J}_1 \hspace{1em} \ldots \hspace{1em} \mathcal{J}_n \)}
  \RightLabel{\( \mathsf{(name)} \)}
  \UnaryInfC{\( \mathcal{J} \)}
\end{prooftree}
\]</span></p>
<p>The <span class="math inline">\( \mathcal{J}_i \)</span>s above the horizontal line are the judgments. They are the premises of this rule. The inference rule allows us to write the horizontal line and the additional judgment <span class="math inline">\( \mathcal{J} \)</span> when all the premises are there. The <span class="math inline">\( \mathsf{(name)} \)</span> is the name of the rule.</p>
<p>Let's see actual rules. The first one is the rule of variable:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( (\mathsf{var}) \)}
  \UnaryInfC{\( \Gamma, A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>This is an inference rule that doesn't need any premises. That's why there is nothing above the horizontal line. Intuitively, this rule can be read like "When <span class="math inline">\( A \)</span> is assumed, this <span class="math inline">\( A \)</span> implies <span class="math inline">\( A \)</span>. The same holds when we put additional assumptions <span class="math inline">\( \Gamma \)</span>." Or, more specifically, by adopting the inference rule above, the "<span class="math inline">\( \vdash \)</span>" turns into something that can be compared to "implies" in our language.</p>
<p>Let's see some examples. All of below are correct applications of the rule <span class="math inline">\( \mathsf{(var)} \)</span>:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( B, A \vdash A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, B, C, D \vdash A \)}
\end{prooftree}
\]</span></p>
<p>On the other hand, all of below are incorrect applications of the rule <span class="math inline">\( \mathsf{(var)} \)</span>:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, C \vdash B \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \to A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( \cdot \vdash A \)}
\end{prooftree}
\]</span></p>
<p>Let's move on to the next rule. The next rule is something that embeds the meaning of "<span class="math inline">\( \vdash \)</span>" to the proposion-level construct "<span class="math inline">\( \to \)</span>":</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma, A \vdash B \)}
  \RightLabel{\( (\to_{\mathsf{i}}) \)}
  \UnaryInfC{\( \Gamma \vdash A \to B \)}
\end{prooftree}
\]</span></p>
<p>Intuitively, this is something that should be read as: "When '<span class="math inline">\( \Gamma \)</span> and <span class="math inline">\( A \)</span> implies <span class="math inline">\( B \)</span>' is correct, '<span class="math inline">\( \Gamma \)</span> implies <span class="math inline">\( A \to B \)</span>' is correct." We've just defined the meaning of "<span class="math inline">\( \vdash \)</span>" to be implication — or something that can be compared to it at least — using the rule <span class="math inline">\( \mathsf{(var)} \)</span>. In turn, this inference rule <span class="math inline">\( (\to_{\mathsf{i}}) \)</span> is something that sends the judgement-level symbol "<span class="math inline">\( \vdash \)</span>" into the proposition-level symbol "<span class="math inline">\( \to \)</span>".</p>
<p>The rule above is something that generates a new proposition that contains "<span class="math inline">\( \to \)</span>". In other words, this rule defines when we can say certain proposition. Such an inference rule is said to be an introduction rule. Conversely, a rule that defines what can be said from a proposition is called an elimination rule. The elimination rule of "<span class="math inline">\( \to \)</span>" is as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_{\mathsf{e}}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>This is something that defines how to use an implication "<span class="math inline">\( \to \)</span>". This is a rule that allows us to derive "<span class="math inline">\( B \)</span>" when we know "<span class="math inline">\( A \)</span> implies <span class="math inline">\( B \)</span>" and "<span class="math inline">\( A \)</span>". I believe that there's no surprise here.</p>
<p>We take the three rules above, that is,</p>
<ol>
<li>The rule of variable<br />
</li>
<li>The introduction rule of implication<br />
</li>
<li>The elimination rule of implication<br />
</li>
</ol>
<p>as the inference rules of our logical system. We can easily add, for example, AND, OR, or whatever.</p>
<p>We can generate, for example, the following pattern by applying the rules above repeatedly:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( B, B, A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( B, B \vdash A \to A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( B \vdash B \to (A \to A) \)}
  \AxiomC{\( \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( B \vdash B \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( B \vdash A \to A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \cdot \vdash B \to (A \to A) \)}
\end{prooftree}
\]</span></p>
<p>Such a generated tree is said to be a proof tree, or simply a proof. A proof of <span class="math inline">\( \cdot \vdash B \to (A \to A) \)</span>, in this case.</p>
<h4>Detours in a proof tree</h4>
<p>We can derive a judgement <span class="math inline">\( \Gamma \vdash A \)</span> in various ways. For example, consider proving <span class="math inline">\( \cdot \vdash A \to A \)</span>. Of course, we have the following straightforward proof:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \cdot \vdash A \to A \)}
\end{prooftree}
\]</span></p>
<p>On the other hand, we also have the following redundant proof:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( A \vdash A \to A \)}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \cdot \vdash A \to A \)}
\end{prooftree}
\]</span></p>
<p>The proof above derives the same <span class="math inline">\( \cdot \vdash A \to A \)</span>. The proof tree is, nevertheless, unnecessarily complex.</p>
<p>Where does this complexity come from? Why is the proof tree above unnecessarily big? — That's because the proof tree contains a "detour." Specifically, the "detour" here is the following part:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( A, A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( A \vdash A \to A \)}
  \AxiomC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>This is schematically a proof that introduces the logical connective "<span class="math inline">\( \to \)</span>," and then immediately eliminates the connective. Introduction followed by immediate elimination. But doesn't it mean that we didn't have to introduce the connective after all? In this sense, the above is a "detour." More generally, such a "detour" is of the following form:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, A \vdash B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>That is, a "detour" is a pattern "introduction followed by immediate elimination." Such a "detour" is often called as a redex (Here, the symbols <span class="math inline">\( \mathcal{H}_1 \)</span> and <span class="math inline">\( \mathcal{H}_2 \)</span> represent the upper proof trees).</p>
<p>Let's take five minutes or so and gaze at the redex above. Then we'll see that we can construct a proof tree of <span class="math inline">\( \Gamma \vdash B \)</span> that doesn't contain the redex. The construction can be done as follows. Firstly, focus on the following part:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, A \vdash B \)}
\end{prooftree}
\]</span></p>
<p>Now, suppose that the <span class="math inline">\( A \)</span> in <span class="math inline">\( \Gamma, A \vdash B \)</span> is used somewhere in <span class="math inline">\( \mathcal{H}_1 \)</span>. In such a situation, we replace this <span class="math inline">\( A \)</span> by the <span class="math inline">\( A \)</span> in the following proof tree:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash A \)}
\end{prooftree}
\]</span></p>
<p>By this modification, we now don't have to use the <span class="math inline">\( A \)</span> of <span class="math inline">\( \Gamma, A \vdash B \)</span>. This means that we can prove <span class="math inline">\( B \)</span> without using the <span class="math inline">\( A \)</span> of <span class="math inline">\( \Gamma, A \vdash B \)</span>. That is, if we define <span class="math inline">\( \mathcal{H&#39;}_1 \)</span> to be the proof tree obtained from <span class="math inline">\( \mathcal{H}_1 \)</span> by</p>
<ol>
<li>using <span class="math inline">\( A \)</span> not from the context but from <span class="math inline">\( \mathcal{H}_2 \)</span>, and<br />
</li>
<li>removing the <span class="math inline">\( A \)</span> in the context,</li>
</ol>
<p>then we can derive the following tree:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H&#39;}_1 \)}
  \UnaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>This rewriting operation can be summarized as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, A \vdash B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\hspace{3em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( {\mathcal{H&#39;}_1} \)}
  \UnaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>Such a rewriting operation that resolves a redex is called a reduction. The process of obtaining a proof tree without any redex by reducing the given tree repeatedly is called normalization.</p>
<h4>Normalizing a proof tree / executing a program</h4>
<p>In the discussion above, we've denoted a proof tree by a symbol <span class="math inline">\( \mathcal{H} \)</span>. Here, we consider keeping this information in a more local way. We consider keeping the "log" information of a proof every time we apply an inference rule. The log information must be something that can be used when we want to recover the proof of a judgment under consideration. Firstly, let's see the inference rule of a variable:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( \Gamma, A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>We'd like to add a log information for this inference rule. The log information must be something that be used to tell which <span class="math inline">\( A \)</span> in the context is actually used in the following application:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>Thus we have to give a name to each proposition in the context. More specifically, we'll do as follows. Firstly, take a set that is exactly as big as the set of natural numbers. Let's call this the variable set. We also call an element of this set a variable. Using this, we extend the definition of a quasi-context as follows:</p>
<ol>
<li><span class="math inline">\( \cdot \)</span> is a quasi-context.<br />
</li>
<li>If <span class="math inline">\( \Gamma \)</span> is a quasi-context and <span class="math inline">\( x \)</span> is a varible and <span class="math inline">\( A \)</span> is a proposition, then <span class="math inline">\( \Gamma, x : A \)</span> is a quasi-context.<br />
</li>
<li>No other syntactic construct is a quasi-context.</li>
</ol>
<p>We also define a "proof term" as follows. We're going to use this to keep track of a proof.</p>
<ol>
<li>If <span class="math inline">\( x \)</span> is a variable, then <span class="math inline">\( x \)</span> is a proof term.<br />
</li>
<li>If <span class="math inline">\( x \)</span> is a variable and <span class="math inline">\( e \)</span> is a proof term, then <span class="math inline">\( \lambda x. e \)</span> is a proof term.<br />
</li>
<li>If <span class="math inline">\( e_1 \)</span> and <span class="math inline">\( e_2 \)</span> are proof terms, then <span class="math inline">\( e_1 \mathbin{@} e_2 \)</span> is a proof term.<br />
</li>
<li>No other syntactic construct is a proof-term.</li>
</ol>
<p>Using this "proof term," we extend the definition of a judgment as follows:</p>
<ol>
<li>If <span class="math inline">\( \Gamma \)</span> is a context and <span class="math inline">\( e \)</span> is a proof term and <span class="math inline">\( A \)</span> is a proposition, then <span class="math inline">\( \Gamma \vdash e : A \)</span> is a judgement.<br />
</li>
<li>No other syntactic construct is a judgment.</li>
</ol>
<p>Now we're ready to extend the rule <span class="math inline">\( \mathsf{(var)} \)</span>. It would me more illuminating to show how the example of <span class="math inline">\( A, A \vdash A \)</span> changes:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( x : A, y : A \vdash y : A \)}
\end{prooftree}
\]</span></p>
<p>Now that each proposition in the context has a name like <span class="math inline">\( x \)</span> or <span class="math inline">\( y \)</span>, we can keep the information that shows the "active" proposition in the application of the rule <span class="math inline">\( \mathsf{(var)} \)</span>. As a inference rule, the <span class="math inline">\( \mathsf{(var)} \)</span> is extended as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( \Gamma, x : A \vdash x : A \)}
\end{prooftree}
\]</span></p>
<p>The log information of the derivation of a judgment is saved in <span class="math inline">\( e \)</span> of <span class="math inline">\( \Gamma \vdash e : A \)</span>.</p>
<p>Let's move on to the introduction rule of "<span class="math inline">\( \to \)</span>". This is extended as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma, x : A \vdash e : B \)}
  \RightLabel{\( (\to_{\mathsf{i}}) \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x. e : A \to B \)}
\end{prooftree}
\]</span></p>
<p>The premise of the introduction rule of "<span class="math inline">\( \to \)</span>" is now turned into <span class="math inline">\( \Gamma, x : A \vdash e : B \)</span>. This is just because the definition of a judgment is extended. No surprises. Also, we now have a really connotative proof term <span class="math inline">\( \lambda x. e \)</span> in the conclusion. This is, however, just a term that keeps track of a fact that we applied the extended introduction rule of "<span class="math inline">\( \to \)</span>," focusing on the variable <span class="math inline">\( x \)</span>. This is just a log of a proof. Such an extension is an automatic process; we don't need any creativity here.</p>
<p>Finally, let's move on to the elimination rule of "<span class="math inline">\( \to \)</span>". This is extended as follows:</p>
<p><span class="math display">\[
\newcommand{\app}[2]{#1 \mathbin{@} #2}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e_1 : A \to B \)}
  \AxiomC{\( \Gamma \vdash e_2 : A \)}
  \RightLabel{\( (\to_{\mathsf{e}}) \)}
  \BinaryInfC{\( \Gamma \vdash \app{e_1}{e_2} : B \)}
\end{prooftree}
\]</span></p>
<p>Again, we simply added the required proof terms to the rule. No surprises.</p>
<p>Now, let's add proof terms to our detours that we saw above. It generates the following proof tree:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, x : A \vdash e_1 : B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x. e_1 :  A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash \app{(\lambda x. e_1)}{e_2} : B \)}
\end{prooftree}
\]</span></p>
<p>It looks like, well, something. Let's continue this line pretending ignorance. Remember the operation of resolving a redex. It is, after all, the operation of replacing the use of <span class="math inline">\( x : A \)</span> by <span class="math inline">\( e_2 : A \)</span>. This means that the resulting proof term is the term that can be obtained by replacing all the <span class="math inline">\( x \)</span> in <span class="math inline">\( e_1 \)</span> by <span class="math inline">\( e_2 \)</span>. That is to say, the rewriting operation is summarized as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, x : A \vdash e_1 : B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x. e_1 :  A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash \app{(\lambda x. e_1)}{e_2} : B \)}
\end{prooftree}
\hspace{3em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( {\mathcal{H&#39;}_1} \)}
  \UnaryInfC{\( \Gamma \vdash e_1 \{x := e_2\} : B \)}
\end{prooftree}
\]</span></p>
<p>Here, the <span class="math inline">\( \{x := e_2\} \)</span> is the operation of substitution that replaces all the occurences of the variable <span class="math inline">\( x \)</span> by the term <span class="math inline">\( e_2 \)</span>. We won't go into its rigorous definition here; It's something that translates <span class="math inline">\( x + y + x \)</span> into <span class="math inline">\( e_2 + y + e_2 \)</span>. I believe that your wisdom can imagine its basic behavior.</p>
<p>Anyway, finally, by focusing on the behavior of the proof terms in the reduction above, we obtain the following (hopefully familiar) reduction rule:</p>
<p><span class="math display">\[
  \app{(\lambda x. e_1)}{e_2} \leadsto e_1 \{x := e_2\}
\]</span></p>
<p>Starting from investigating natural deduction, we've reached to the viewpoint of lambda calculus (or programming). From this viewpoint, a judgement <span class="math inline">\( x_1 : A_1, \ldots, x_n : A_n \vdash e : A \)</span> is now read as: "with free variables <span class="math inline">\( x_1 : A_1, \ldots, x_n : A_n \)</span>, the program <span class="math inline">\( e \)</span> is of type <span class="math inline">\( A \)</span>." Especially, a proposition is now interpreted as a type. This story continues like, for example, "resolving a detour in a proof tree is executing a program," or "how we resolve detours in a proof tree corresponds to how we execute a program (like call-by-value, call-by-name)," etc.</p>
<p>This relation between a proof and a program is often referred to as the Curry-Howard correspondence. Our talk on a proof is always-already reinterpretable as a talk on a program, and vice versa.</p>
<p>This correspondence is enlightening and exciting. By extending the proof-side discussion to be able to, for example, represent something like "<span class="math inline">\( P \)</span> is necessarily true," we can obtain <a href="https://www.cs.cmu.edu/~fp/papers/popl96.pdf">the concept of staged computation (something like the quasiquote in lisp)</a> by reinterpreting necessity in the program-side.</p>
<h3>Motivation from proof theory, or the ice-cold correspondence</h3>
<h4>The ice-cold correspondence</h4>
<p>Well, this is the end of an ordinary introduction of the Curry-Howard correspondence. In this article, however, the story doesn't end here. Hey, I was fairly impressed when I first know the correspondence. That's why I tried to create a programming language that utilizes the correspondence to the maximum degree possible. A programming language in which any computational concepts in the language are supported by some proof-theoretic concepts.</p>
<p>A variable can be reinterpreted easily. The introduction rule of implication is easy. The elimination rule is also easy. This and that logical connectives can be added in a straightforward manner. A fixed point operator can be easily added, which makes the language Turing complete. Polymorphism can be realized by extending the logical system to a weak variant of predicate logic. Type inference can be implemented using the well-known method. "Okay, everything seems to be all right," and this is how I reached to the question: "—But how can I manage memory in this language?"</p>
<p>Then I investigated existing languages that have proof-like / lambda-like flavor. They seem to use GC (OCaml, Haskel, F#, Idris, Coq, Agda, Lean). Fair enough. All of them are great in their own way, of course. At the same time, however, it is also a fact that they didn't satisfy my current curiosity; I failed to find one that manages memory in a proof-theoretic way.</p>
<p>All in all, yes, the Curry-Howard correspondence is something that allows us to compare a logical system with an idealized programming language. What I found at the time was that, when considering a real programming language, the aspect of memory management was dealt with as something that should be resolved at the implementation level. It seemed to be recognized as an irregular part of a real programming language, a part that strays from the pure, ice-cold correspondence.</p>
<h4>What about the region-based approach?</h4>
<p>What we'll find when we continue surveying existing works on memory management is the region-based approach. The approach is something that computes the information that is required to realize static memory management by adding annotations to the type system. A great approach. It indeed realizes static memory management. It can, for example, statically detect a wrong use of memory like free-after-free.</p>
<p>However, I was too greedy to accept the approach as an answer to the question. I didn't want to add annotations that don't live in the intuitionistic logic. I didn't want to add non-proof-theoretic, implementation-oriented constructs. I wanted to find the vocabulary for memory management <strong>in</strong> the usual, our familiar natural deduction. I wanted to retain the scheme of "thinking about proofs is always-already thinking about programs" when we thought about memory. That's why I couldn't simply accept the region-based approach, even if the approach is indisputably brilliant under other situations.</p>
<p>I think we should visit the method called "region-inference" here. This is an extension of the ordinary type inference that infers not only type information but also region information — information that can be used to realize static memory management. Using this method, for example, a compiler for Standard ML (A language specification that is similar to OCaml) with static memory management is <a href="https://sourceforge.net/projects/mlkit/">developed</a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>What this implies is that we can realize static memory management for a program that is written in the range of the intuitionistic logic. So isn't this an answer? A language with region-based memory management and region inference. Isn't this the answer that I've been looking for?</p>
<p>The response to this starts by considering the following program in which the type annotation of the lambda abstraction is omitted:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>λx. (not x, 10)</span></code></pre></div>
<p>When inferring the type of the code above, the compiler would generate a metavariable <code>?M</code> that stands for the type of <code>x</code>. That is, the compiler would generate a term like this:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>λ(x : ?M). (not x, 10)</span></code></pre></div>
<p>Then the compiler generates constraints like <code>bool = ?M</code>, using the known type information like <code>not : bool -&gt; bool</code>. The generated constraints are in turn resolved, resulting in a substitution like <code>?M := bool</code>. This substitution is applied to the term above, resulting in the following term:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>λ(x : bool). (not x, 10)</span></code></pre></div>
<p>Thus we now know that the original program is actually an abbreviation of this fully-elaborated program. The point here is that the metavariable <code>?M</code> is inserted in the way above just because the type inference algorithm is defined to do things in that way. If we, for example, want to obtain the number of times that a variable used, the compiler would generate a term like this:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>λ(x : &lt;?M, ?n&gt;). (not x, 10)</span></code></pre></div>
<p>And this term is elaborated into:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>λ(x : &lt;bool, 1&gt;). (not x, 10)</span></code></pre></div>
<p>This means that the original program is actually an abbreviation of this term, in this case. In short, the fully-elaborated form of a program is relative to the type inference algorithm.</p>
<p>Now, region inference is a variant of type inference. This means that a program written in a language with region inference is elaborated in the context of region inference. A program in such a language will be something that can contain abbreviations of not only types but also regions, just like the metavariable <code>?n</code> in the example above. The situation is something like: "We can technically write information on region explicitly, but all of them are accidentally abbreviated this time."</p>
<p>This sums up to the following conclusion: in a language with region inference, even if we might be able to write a program that seems to be closed in the intuitionistic logic, it is actually a program with implicit region information — and the information is actually there as a result of elaboration. Changing the behavior of its type inference algorithm means changing how a program is interpreted as an abbreviation. The approach with region inference is, therefore, reduced to the approach with the ordinary region-based memory management. That's why the approach isn't satisfying for the current curiosity.</p>
<h4>Motivation</h4>
<p>This is where we come to reach our motivation; We want to realize memory management in a natural-deduction based programming language, without adding annotations to its type system. We want to find the vocabulary for memory management <strong>in</strong> our language (= the intuitionistic logic). We want to realize memory management in a Curry-Howard-y way.</p>
<p>From this viewpoint, this article is something that answers to the requirement above in a positive way. This article is something that shows how to realize such a resource management system, with an accompanying proof-of-concept implementation. A real programming language can still live in the ice-cold correspondence, after all.</p>
<p>This finally gives the background motivation to this article. It was a long run.</p>
<p>— But why after all do we use η-expansion rather than anything else? As we've already seen in the main part, we can leverage η-expansion to use the resource information of a type. Why thinking about η-expansion is related to thinking about resource management? We'll focus on this point in the next section.</p>
<h3>Computational significance of local completeness</h3>
<h4>Local soundness</h4>
<p>Let's go back to the proof-theoretic talk<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. We've already seen the concept of reduction. An operation that resolves a detour in a proof tree. Let's focus on this. Now, for example, suppose that we want to add the logical connective "AND" to our logical system. We'll write the "AND" of <span class="math inline">\( A \)</span> and <span class="math inline">\( B \)</span> as <span class="math inline">\( A \land B \)</span>. How the introduction rule and the elimination rule of "<span class="math inline">\( \land \)</span>" should be?</p>
<p>Well, defining the introduction rule and the elimination rule itself is not that difficult. The introduction rule should be something like this:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
\end{prooftree}
\]</span></p>
<p>That is, we need to know <span class="math inline">\( A \)</span> and <span class="math inline">\( B \)</span> to derive <span class="math inline">\( A \land B \)</span>. The elimination rules can also be easily added as follows, for example:</p>
<p><span class="math display">\[
\newcommand{\andlet}[3]{\mathsf{let}\, #1 := #2\, \mathsf{in}\, #3}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}\, e : A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}\, e : B \)}
\end{prooftree}
\]</span></p>
<p>The reduction rules for this logical connective will be something like this:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(e_1, e_2) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
\end{prooftree}
\]</span></p>
<p>and this:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(e_1, e_2) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
\end{prooftree}
\]</span></p>
<p>No surprises until here.</p>
<p>Now, let's sell our souls to the devil and consider replacing the introduction rule of "<span class="math inline">\( \land \)</span>" by the following two rules:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
\end{prooftree}
\]</span></p>
<p>Yes, broken, obviously. We don't even know how to interpret them. These magics are so broken that we can derive any proposition <span class="math inline">\( B \)</span> from any proposition <span class="math inline">\( A \)</span>:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\]</span></p>
<p>They can break the logical system behind them. We shouldn't accept such a pair of the introduction rules and the elimination rules.</p>
<p>The experiment above tells us that there must be certain relations between the introduction rules and the elimination rules of a logical connective, and that without it we would have a broken, insane, unsound logical connective. Then, in turn, what sort of relations does a logical connective need for it to be sane?</p>
<p>What if we just say "It'll break the system. I know. So what?" here? Let's try continuing the talk on our broken "<span class="math inline">\( \land \)</span>". As in the case of ordinary "<span class="math inline">\( \land \)</span>", we'll have to define its reduction rules for this insane logical connective. The detours for this connective are the following four, resulting from the two introduction rules and the two elimination rules:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(\mathsf{magic}_\mathsf{L}\, e) : A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(\mathsf{magic}_\mathsf{R}\, e) : A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{R}\, e) : B \)}
\end{prooftree}
\]</span></p>
<p>The reduction rule for the first one should be easily defined as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(\mathsf{magic}_\mathsf{L}\, e) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
\end{prooftree}
\]</span></p>
<p>Similarly for the fourth rule:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{R}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
\end{prooftree}
\]</span></p>
<p>The second and the third one are, however, problematic. Let's take the second one for example:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{?} : B \)}
\end{prooftree}
\]</span></p>
<p>We can't resolve the detour above. That's because, to resolve the detour, we need to prove the conclusion of the elimination rule (here it's <span class="math inline">\( B \)</span>) from the premise of the introduction rule (here it's <span class="math inline">\( A \)</span>), which is impossible. As a comparison, let's review the reduction of the ordinary "<span class="math inline">\( \land \)</span>":</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(e_1, e_2) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
\end{prooftree}
\]</span></p>
<p>We can see that the conclusion of the elimination rule (here it's <span class="math inline">\( A \)</span>) is shown using the premises of the introduction rules (here they're <span class="math inline">\( A \)</span> and <span class="math inline">\( B \)</span>, though only <span class="math inline">\( A \)</span> is used this time).</p>
<p>After all, the operation of resolving a detour is the operation of proving the conclusion of an elimination rule from the premises of the introduction rules<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. That is to say, we can define the reduction rules only when we can prove all the possible results of elimination from the premises of the introduction rule. That is to say, the elimination rules shouldn't be too strong with respect to the introduction rules — if an elimination rule is too strong, it can derive a proposition that strays from the range that is covered by the premises of an introduction rule.</p>
<p>As for the ordinary "<span class="math inline">\( \land \)</span>", all the possible propositions obtained by eliminating <span class="math inline">\( A \land B \)</span> — which is <span class="math inline">\( A \)</span> and <span class="math inline">\( B \)</span> — must be shown from the premises of the introduction rule — which is <span class="math inline">\( A \)</span> and <span class="math inline">\( B \)</span>. This property is indeed satisfied, and that's why we can define the reduction rule of "<span class="math inline">\( \land \)</span>".</p>
<p>On the other hand, as for the crazy "<span class="math inline">\( \land \)</span>", the proposition <span class="math inline">\( B \)</span> obtained by eliminating <span class="math inline">\( A \land B \)</span> can't be show from the premise of its introduction rule when the premise of the introduction rule is <span class="math inline">\( A \)</span>:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{?} : B \)}
\end{prooftree}
\]</span></p>
<p>That's why we can't define the reduction rule for this connective.</p>
<p>A logical connective for which we can define the reduction rules is said to have local soundness. The lack of local soundness means the possibility of deriving propositions that shouldn't be derived. We can summarize here that our broken logical connective is broken in that it doesn't have local soundness.</p>
<h4>Local completeness</h4>
<p>By summarizing things in the way above, now we can consider a property that can be obtained by reversing local soundness. Or equivalently, a property that ensures that the elimination rule is not too weak. This property is called as local soundness.</p>
<p>Remember that we can characterize the property of local soundness as a possibility of rewriting proof trees — the possibility of reduction. Similarly, we can characterize the property of local completeness as a possibility of rewriting proof trees. We'll explain the characterization taking <span class="math inline">\( A \land B \)</span> as an example. Assume that we have a proof tree of <span class="math inline">\( e : A \land B \)</span>. In this situation, suppose that we can construct a proof tree of <span class="math inline">\( A \land B \)</span> that satisfies both of the followings:</p>
<ol>
<li>Every occurrence of a premise in the proof tree is of the form <span class="math inline">\( e : A \land B \)</span><br />
</li>
<li>Every occurrence of a premise <span class="math inline">\( e : A \land B \)</span> is immediately eliminated</li>
</ol>
<p>In this situation, we say that the "<span class="math inline">\( \land \)</span>" has local soundness. This mysterious definition needs an explanation, of course. Let's start from performing such a rewriting operation (expansion) to <span class="math inline">\( A \land B \)</span>:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \land B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{left}\, e : A \)}
  \AxiomC{\(  \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{right}\, e : B \)}
  \BinaryInfC{\( \Gamma \vdash (\mathsf{left}\, e, \mathsf{right}\, e) : A \land B \)}
\end{prooftree}
\]</span></p>
<p>We can easily check that the expanded proof tree of <span class="math inline">\( A \land B\)</span> satisfies the properties above.</p>
<p>Now, suppose that the elimination rule is too weak. In this case, by the condition "every <span class="math inline">\( A \land B \)</span> is immediately eliminated", the information of <span class="math inline">\( A \land B \)</span> can only be used in some incomplete way. That is to say, we shouldn't be able to recover a proof of <span class="math inline">\( A \land B \)</span> in this case. For example, consider removing the following rule from the elimination rule of <span class="math inline">\( A \land B \)</span>:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{right}\, e : B \)}
\end{prooftree}
\]</span></p>
<p>In this case, we can't construct the branch of <span class="math inline">\( \mathsf{right}\, e : B \)</span>, and we can't recover "<span class="math inline">\( A \land B \)</span>". Thus the "<span class="math inline">\( \land \)</span>" in this case doesn't have local completeness — its elimination rule is too weak.</p>
<p>Conversely, by the fact that we can recover <span class="math inline">\( A \land B \)</span>, we can see that the elimination rules of <span class="math inline">\( A \land B \)</span> is not too weak. That's why the possibility of such an expansion supports the local soundness of "<span class="math inline">\( \land \)</span>".</p>
<h4>Local soundness and time / local completeness and space</h4>
<p>Generally speaking, we don't much care about local completeness (and its corresponding expansion) when we think about the operational behavior of a program. It's almost ignored, and we often focus only on reduction. Well, that can be an overstatement, but there's that sort of vibe, I believe. Indeed, for example, when we want to think about the operational behavior of a programming language which is based on a certain form of lambda calculus, we only have to focus on its reduction, and we can simply ignore its local completeness.</p>
<p>At the same time, however, I find it a little mysterious. It's ultimately just our convenience that we exclusively utilize the reductional aspect of a logical system. The logical system won't give a damn to our these busy activities, so to speak. It might be, then, reasonable to some degree to think that the expanding operation can have as much significance as the reducing operation. They're the two sides of the same coin, after all<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. That's how I've come to think that local expansion could be utilized to realize some important aspect of computation, and that the aspect should be something that complements the reductional aspect.</p>
<p>Now, by the way, it won't be a sin to say that reduction is something that rules over the behavior of a program with respect to time. What can be, then, obtained by taking the other side of time? If we bring a computer scientist here and ask them about it, we'll see them saying that it's space. This pushes us even further: We might be able to utilize local completeness to realize memory management.</p>
<p>From this viewpoint, this article is something that does realize static memory management – control the behavior of a program with respect to space — via local completeness. In other words, this article gives support to the following (dubious) contrast:</p>
<ul>
<li>Local soundness gives a foundation of a program with respect to time<br />
</li>
<li>Local completeness gives a foundation of a program with respect to space</li>
</ul>
<p>Well, I know that this part is too rough and unsupported. It's unsupported enough to make me think that I should insert some self-ironical meme here, but unfortunately I can't since I'm not familiar with English memes. Anyway, having said that though, it's also a fact that the starting point of this article is around here, and that's why I chose to write down these thoughts, despite its sketchiness.</p>
<h3>A foundation for the resource management via copy/discard</h3>
<p>Let's move on to the next topic. Here we'll see an additional explanation of an aspect of the method in this article. That is, we'll see what kind of foundation can be found for the copy/discard approach.</p>
<p>Let's take the following ordinary reduction in lambda calculus as an example:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>   (λ x. (x, x)) @ &quot;hello&quot;</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>~&gt; (&quot;hello&quot;, &quot;hello&quot;)</span></code></pre></div>
<p>We name both of the terms in the reduction above as follows, just for explanation purpose:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>e1 := (λ x. (x, x)) @ &quot;hello&quot;</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>e2 := (&quot;hello&quot;, &quot;hello&quot;)</span></code></pre></div>
<p>The reduction above can be written as <code>e1 ~&gt; e2</code>, of course.</p>
<p>Now, consider comparing the behavior of the code <code>e1</code> and the code <code>e2</code> in a pure language with garbage collection. In this case, obviously, the behaviors of them are different in whether the computation that corresponds to the reduction above will occur or not. True, but that isn't the end of the story; We still have the following difference in space:</p>
<ul>
<li>When we write <code>e1</code> in our code, the string <code>"hello"</code> is, once created, shared in <code>(x, x)</code>. That is, when the program is in the state that corresponds to <code>("hello", "hello")</code>, the first and the second element of the tuple refer to the same memory region (the address of the string <code>"hello"</code>).<br />
</li>
<li>When we write <code>e2</code> in our code, the string <code>"hello"</code> is simply created twice.</li>
</ul>
<p>The string <code>"hello"</code> is created only once in the code <code>e1</code>, but twice in the code <code>e2</code>. That is to say, the behavior of a program with respect to space varies, depending on whether we write the former term or the latter term of the reduction <code>e1 ~&gt; e2</code>. That is to say again, the reduction doesn't preserve the result of computation with respect to space.</p>
<p>Then what will happen when we require the reduction rule to preserve the result of a program with respect to not only time but also space? In this case, the code <code>e1</code> must create the same number of copies of the string <code>"hello"</code> as that of <code>e2</code>. That is, 2 copies, and this "2" comes from, of course, the number of the <code>x</code> in the following code:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>λ x. (x, x)</span></code></pre></div>
<p>Thus the behavior of <code>e1</code> must be something as follows (adopting call-by-value):</p>
<ol>
<li>A piece of memory region for the string <code>"hello"</code> is allocated and initialized<br />
</li>
<li>The string is passed to the lambda abstraction<br />
</li>
<li>(Let n be the number of the times that the variable <code>x</code> is used in the lambda abstraction)<br />
</li>
<li>The lambda abstraction copies / discards the argument (= the string) to create n copies of it<br />
</li>
<li>Execute the remaining computation</li>
</ol>
<p>In this interpretation, the <code>e1</code> indeed creates two copies of <code>"hello"</code>. This gives a foundation for the copy/discard approach. That is, the approach is something that is automatically required when we request the reduction rule to preserve the result of computation with respect to not only time but also space.</p>
<h3>Can we expect acceptable performance from this approach?</h3>
<p>By the way, thinking things soberly, it is nothing but a crazy deed to copy the value of a variable every time when we use it. The word "wasteful" can't be enough for this. It's a violation of CPU rights. One might be lead to say that the approach presented in this article is something that can be meaningful only in the ivory tower, and that it is infeasible in our rough real world. The actual situation is, however, not that tragic. As is often the case, the ivory tower has a secret passage; Optimization.</p>
<p>We'll see three possible optimizations below. The most interesting aspect of this section would be, rather than the detail of each optimization, the fact that all of those optimizations are formulated by the words that specify how we should write a term in our language. The fact that we recognize vocabulary for resource management <strong>in</strong> the existing lambda calculus.</p>
<p>As expected, we won't see any benchmarks or that sort of thing here. Again, please take the content below with a grain of salt, and a bag of popcorn if you like.</p>
<h4>Borrowing-like operation</h4>
<p>The first one. Consider the following code:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>let str := &quot;hello&quot; in</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>let _ := print str in</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>let _ := print str in</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>print str</span></code></pre></div>
<p>The code above prints <code>"hello"</code> for the three times. We can see that the variable <code>str</code> is used for the three times. Thus the code above creates three copies of <code>"hello"</code>. That just sounds terrible.</p>
<p>We can, however, avoid this situation with a little thought. The point here is the type of <code>print</code>. We can set the type of <code>print</code> not <code>string -&gt; top</code>, but <code>string -&gt; string * top</code>. That is, we set <code>print</code> as a primitive function with the following behavior:</p>
<ol>
<li>Receives a string <code>s</code> as the argument of it<br />
</li>
<li>Prints <code>s</code><br />
</li>
<li>Returns the pair of <code>s</code> and <code>unit</code><br />
</li>
</ol>
<p>With this <code>print</code>, the code above can be rewritten as follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>let str := &quot;hello&quot; in</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>let (str1, _) := print str in</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>let (str2, _) := print str1 in</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>print str2</span></code></pre></div>
<p>Or, renaming the variables,</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>let str := &quot;hello&quot; in</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>let (str, _) := print str in</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>let (str, _) := print str in</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>print str</span></code></pre></div>
<p>With this rewriting, we can avoid the copying operations for <code>"hello"</code> in the original code.</p>
<p>By the way, I noticed that the above pattern of "attaching an argument to its result as it is" occurs frequently. That's why I added a dedicated syntax for it in the language that I implemented this time. That is, if we write a term something like below:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>let _ := print &amp;str in (...)</span></code></pre></div>
<p>This term is, then, translated into the term:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>let (str, _) := print str in (...)</span></code></pre></div>
<p>in the parsing stage (Although the actual looking is a little different since the actual syntax is S-expression based, what happens is essentially as above). It looks like borrowing, though I think I should refrain from using this word here so as not to cause the name collision to the proper ones in C++ or Rust.</p>
<p>Anyway, using this syntax, we can write, for example, a function that prints the received string twice as follows:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>let print_twice :=</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  λ str.</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;str in</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;str in</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    (str, top.unit)</span></code></pre></div>
<h4>State and shadowing</h4>
<p>The second one. Suppose that we want to realize a computation with states. In what way should we implement it? Of course, we can use the state monad, leveraging the power of the lambda calculus. This approach has, however, a problem. Let's see how the <code>get</code> of the state monad is implemented:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>let get :=</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  λ s. (s, s)</span></code></pre></div>
<p>Here the <code>s</code> is a variable that receives the state. If the state monad has, for example, <code>string</code> as its state, then the <code>s</code> receives a string. Now the problem should be clear: Since the variable <code>s</code> is used in a non-linear way (twice), the string is copied every time when we call the function <code>get</code>. The state is copied as a whole every time when we use the state. A tragedy. That makes us seek an alternative approach.</p>
<p>And luckily there indeed is such an alternative approach: We just have to apply the shadowing-based optimization that we've seen above to a top-level variable. I think this can be best explained by an example:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>-- define a variable to keep state information</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>let str-state :=</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  &quot;hello&quot; in</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>-- define a function that receives the state `s`, compute using that state, and returns the pair `({updated state}, unit)`</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>let proc :=</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  λ s.</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;s in</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    let s := concat s &quot;!&quot; -- append &quot;!&quot; to the current state (string)</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;s in</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>    (s, top.unit) in</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>-- use the borrowing-like operation at top level</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>let _ := proc &amp;str-state in</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>-- the above is equivalent to `let (str-state, _) := proc str-state`, and thus str-state is &quot;hello!&quot; here</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>-- do the same thing again</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>let _ := proc &amp;str-state in</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>-- str-state is &quot;hello!!&quot; here</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>(...)</span></code></pre></div>
<p>Note that the variable for a state (<code>str-state</code> in this case) is used linearly, that we can read the value of the state, and that we can "write" a new value to the state. This allows us to realize a state-related computation without causing wasteful copy operations of the state. We can easily add a syntax sugar for this kind of operation, of course. This resolves the problem of computation with states.</p>
<h4>Cancelling malloc/free</h4>
<p>The third one. Remember that our language determines memory allocation/deallocation in a static way. This means, as a matter of course, that we should know, at the time when the compilation is finished, where to insert <code>mallloc</code> s and <code>free</code> s, and the size of the memory region that a malloc/free should handle. Thus the resulting code will be conceptually something like this:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>a := malloc(SIZE);</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>free(a);</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>b := malloc(SIZE);</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>free(b);</span></code></pre></div>
<p>Here, since the <code>a</code> and <code>b</code> are of the same size, we can reuse the region of <code>a</code> for <code>b</code>. Thus, the code above should be able to be rewritten as follows:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>a := malloc(SIZE);</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>b := a;</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>free(b);</span></code></pre></div>
<p>And this is indeed possible. This optimization is implemented in the actual language.</p>
<h4>Summary of performance</h4>
<p>So, to what extent these optimizations work well in real life? Can we expect acceptable performance from this approach? The most honest answer from me is, as expected, the "I don't know." Personally, I'm thinking that the range that can be covered by the linear lambda calculus is, thanks to the method that we've seen above, actually larger than we would expect at first, but this is nothing but a sheer imagination that isn't supported by anything. I, of course, want to develop the current implementation into a more full-fledged one so that I can test its performance using some profiling tools, but my lack of this and that resources don't allow me to do that.</p>
<p>Incidentally, it might also be of interest to investigate what will happen when we take multi-threaded behavior into account. I reckon that we can't send/receive states between threads as long as we realize the "write" operation on states by means of shadowing (since the result of the "write" operation in a thread can't be reflected in the other threads), but I don't know to what extent this difference is significant.</p>
<p>I also ran into <a href="https://arxiv.org/abs/1802.00961">a work that investigates multi-threaded behavior via the Curry-Howard correspondence</a>. The research utilizes a generalization of the Gödel's axiom (Here, the axiom is like <span class="math inline">\( (A \to B) \lor (B \to A) \)</span>). I find it intriguing. At the same time, however, I find the reduction rule in the research rather complex — at least for me. Although it might be possible that if I fully understand the work then the reduction rules can be derived immediately in some simple, principled way, currently I don't think that I can incorporate it into the language as it is. Or should I add mysterious constants and use them as black-boxes that realize multi-threaded behavior? I'm not sure.</p>
<h3>Miscellaneous</h3>
<p>Some additional notes, basically on things that I left undone.</p>
<h4>On safety</h4>
<p>As I wrote at the beginning of this article, I don't have any proof that guarantees the safety or the correctness of the approach in this article. This is simply a result of my limited resource.</p>
<p>Regarding safety, I think I should mention the inconsistency of the logic here. Since the logical system of the language admits <code>Type : Type</code> (Or, since it has a fixed point operator), the logical system is obviously inconsistent. That is, for any type <code>A</code>, we can construct a proof term <code>e</code> such that <code>e : A</code>. Also, remember that the resource management system in this article is based on type. This might pose a question: Can't we destroy the proof-theoretic resource management system by exploiting the inconsistency of the logic?</p>
<p>Trying it out in actual code, however, we can see that the execution of such <code>e</code> just results in an infinite loop. Admitting <code>Type : Type</code> doesn't mean admitting, for example, <code>"hello" : int</code>. The <code>e</code> in a proof <code>e : A</code> follows a certain pattern even when we construct the <code>e</code> using <code>Type : Type</code> or <code>fix</code>. Such a logic is consistently inconsistent, so to speak, though I don't have any proof for this, as usual.</p>
<h4>Where's a denotational semantics?</h4>
<p>As anyone with certain knowledge can see within 0.2 seconds, this article is heavily biased towards the syntax side, or the proof-theoretic side. Equivalently, this article doesn't contain any information on a denotational semantics of the system. I personally think that translating a type into a term is interesting in its own way, and am interested in its behavior from the viewpoint of categorical semantics. I'm, however, currently not very good at categorical semantics of dependent type theory.</p>
<h4>On the lack of theoretical backgrounds</h4>
<p>Related to the above-mentioned point, as you may have already noticed, the theoretical backgrounds of this article is far from complete. Being a little technical, the actual compiler behaves basically as follows:</p>
<ol>
<li>begins from receiving a program written in the Calculus of Constructions (an intuitionistic logic on steroids)<br />
</li>
<li>translates the program into the one in a dependent variant of the Call-By-Push-Value<br />
</li>
<li>applies closure conversion so that all the lambda abstractions in the program are closed<br />
</li>
<li>linearizes all the resources via our computational interpretation of type<br />
</li>
<li>generates virtual machine code as usual</li>
</ol>
<p>Frighteningly enough, I didn't give any proofs that guarantee the correctness of the translations included in the above. I didn't even check that the dependent variant of CBPV isn't broken. Generally speaking, as we all know, a seemingly well-designed idea in our mind is doomed to be found broken when we try to re-articulate it on a piece of paper; Even though we do have a working implementation, it is still possible that we find an inherent vice in the approach<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<h4>On the name</h4>
<p>Let me digress a little before concluding the article. I went with naming the language "Neut" this time. Here, I'd like to emphasize that I don't have any thought of, like, "This language is neutral in an important aspect!" or whatever. Indeed, the language is obviously opinionated in that, for example, it adopts the viewpoint of "I ♡ natural deduction". Rather, the name came from its implementation.</p>
<p>As mentioned above, the compiler translates an intuitionistic lambda calculus (the Calculus of Constructions) into a dependent variant of a calculus called Call-By-Push-Value (CBPV). The main difference between CBPV and an ordinary calculus would be the point that CBPV has two kinds of type. More specifically, CBPV has "type for value" and "type for computation"; The former are normally said to be positive, and the latter to be negative. That is, the language has polarity. The introduction rule of, for example, "<span class="math inline">\( \to \)</span>" in CBPV is as follows:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma, x : P \vdash e : N \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x.e : P \to N \)}
\end{prooftree}
\]</span></p>
<p>Here, the <span class="math inline">\( P \)</span> stands for a positive type, and the <span class="math inline">\( N \)</span> for a negative type. We can easily see that the argument of a lambda abstraction must be positive (<span class="math inline">\( x : P \)</span>), and that the body of the abstraction must be negative (<span class="math inline">\( e : N \)</span>). Also, the <span class="math inline">\( P \to N \)</span> itself is set to be a negative type, and thus it can't be, for example, passed to another lambda abstraction as an argument without some modification.</p>
<p>If it's allowed to say that linear logic is something that enables us to investigate logic further with respect to resources, it might also be allowed to say that CBPV is something that enables us to investigate logic further with respect to reduction (too rough?). More information on CBPV can be found <a href="https://www.cs.cmu.edu/~fp/courses/15816-f16/lectures/21-cbpv.pdf">here</a>; The lecture note should be readable with basic knowledge of natural deduction. <a href="https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf">The dissertation by Levy</a>, who created/discovered the CBPV, is even more detailed, though it can be overwhelming.</p>
<p>Anyway, the point here is that the compiler polarizes an input by a user. From this perspective, a program doesn't have polarity at first, and it is neutral in that sense. What a user writes is a neutral proof term. So, just like we write text in a text file and set its extension to be ".txt", I chose to set the extension of a file that write a neutral term ".neut", and also went with using it as the name of the language. That's the whole story.</p>
<h2>Afterword</h2>
<p>GG.</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>When trying to recover the expressivity of intuitionistic logic starting from linear logic, the first approach that one comes up with would be to use the famous exponential modality <code>!</code>. This approach, however, doesn't seem to work well. Consider adding the modality to the system, and admitting the weakening/contraction operation for the propositions with the modality (that is, the propositions of the form <code>!A</code>). In this situation, the modified system essentially contains the intuitionistic logic as a fragment — a fragment in which all the propositions are of the form <code>!A</code>. This makes us go back to the starting point: "How can we manage memory in a system based on the intuitionistic logic?"<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>A question can be posed here: What will happen when a type contains free variables? The short answer is that this sort of situation is handled by the generalized concept of a free variable. That is, the concept is generalized so that free variables in a type of a term are also regarded as free variables of the term. For example, consider the following term:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>λ (A : Type). λ (x : A -&gt; int). (x, 100)</span></code></pre></div>
<p>Normally, the free variable of <code>(x, 100)</code> is considered to be simply <code>x</code>. With our generalization, however, since the type of <code>x</code> (i.e. <code>A -&gt; int</code>) contains <code>A</code> as its free variable, this <code>A</code> is also counted as a free variable. Also, since the type of <code>A</code> (i.e. <code>Type</code>) doesn't contain any free variables, this "tracing" operation ends here, with the result that the free variables of <code>(x, 100)</code> is <code>A, x</code>. In this way, we construct a "closed chain" of all the free variables of a term. We then put it at the first element of a generalized closure so that we can copy the closure later.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>This extension of closure conversion is essentially just an existential quantification. Our familiar existential quantification starts from a statement with free variable(s) like <code>x + 1 = 0</code>, and then create a proposition like <code>exists (x : int). x + 1 = 0</code>, anonymizing the variable <code>x</code>. What the generalized closure conversion does is essentially the same; The type of the closure</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>({the set of free variables},</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a> λ (the original arguments, env).</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   let (the free variables) := env in</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>   {the original code})</span></code></pre></div>
<p>is like:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(A1 * ... * An) * {the type of the closed function}</span></code></pre></div>
<p>The conversion here is something that anonymizes the first element with the existential quantification, creating a term of the following type:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>Sigma (A : Type). A * {the type of the closed function}</span></code></pre></div>
<p>The point here is that the <code>A1 * ... * An</code> is lowered to the term from the type.</p>
<p>Incidentally, this 3-element representation of a closure is not new. Indeed, I was told in <a href="https://github.com/u2zv1wx/neut/issues/1">a GitHub issue</a> that there exists <a href="https://www.ccs.neu.edu/home/amal/papers/closconvcc.pdf">a work</a> that does a similar (the same?) thing. Also, with a quick search, I found <a href="https://sv.c.titech.ac.jp/minamide/papers/popl96.pdf">a work in 1996 that does a similar thing</a>. Thus I emphasize here that I don't claim any originality on this generalization of closure conversion.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>The actual compiler also uses GC so that it can make its output as efficient as possible. I think this can be understood as an optimization, though.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>The content here is mainly based on <a href="https://www.cs.cmu.edu/~fp/papers/mscs00.pdf">this paper</a>, except for the last sketchy part.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>More precisely, the operation of proving the conclusion of an elimination rule using the premises of the introduction rule and the additional premises of the elimination rule. Let's take the elimination rule of "<span class="math inline">\( \to \)</span>" for example:</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_{\mathsf{e}}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>The elimination rule has <span class="math inline">\( A \to B \)</span> and <span class="math inline">\( A \)</span> as its premises. "The additional premises of the elimination rule" is the <span class="math inline">\( A \)</span> here. The example of "<span class="math inline">\( \land \)</span>" is a case in which we have 0 additional premises.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>I found an answer on Stack Exchange saying that <a href="https://math.stackexchange.com/questions/1633210/is-there-a-connection-between-local-soundness-and-completeness-in-proof-theory">they correspond to the triangle identities of an adjunction</a>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>What will happen when a type contains side effects? There can be at least two responses to this situation:</p>
<ol>
<li>To reject such a term at the type checking stage by making the language pure<br />
</li>
<li>To set its behavior undefined, allowing such a term to pass the type checking stage</li>
</ol>
<p>The former approach would set, for example, the type of <code>print</code> to be <code>string -&gt; io (string * top)</code> (the <code>io</code> is our beloved IO monad). By this modification, the type of a "type" that uses <code>print</code> in its definition changes from <code>Type</code> to <code>IO Type</code>. Since the <code>A</code> in <code>A : IO Type</code> can't be used as a type, we can't write, for example, <code>A -&gt; int</code>. We're safe now.</p>
<p>Conversely, the latter approach just says: "It's your fault. Don't write crazy stuff in a type." The actual implementation adopts this approach, by the way.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></summary>
</entry>
<entry>
    <title>型を実行する</title>
    <link href="https://vekatze.github.io/post/2020-10-03.html" />
    <id>https://vekatze.github.io/post/2020-10-03.html</id>
    <published>2020-10-03</published>
    <updated>2020-10-15</updated>
    <summary type="html"><![CDATA[<header>
    <h1>型を実行する</h1>
    
    <span class="metadata">2020-10-03</span>
    
</header>

<p>もともとは次をすべてみたすような言語を探していた：</p>
<ol>
<li>十分に強い型システムをもっている<br />
</li>
<li>普通のλ計算でプログラムを書くことができる<br />
</li>
<li>メモリ管理が静的である</li>
</ol>
<p>まあ我ながらワガママとしか言いようがない。これらすべてをクリアするものはなかなか見つからない。特に3つ目がきつい。最初の2つの条件だけなら単にGCと手をつなげばハッピーエンドであり、実際OCamlとかHaskellとかF#とかで私はたいへん満足なのだが、ここに最後の条件を入れた途端に話はぐっとむずかしくなる。</p>
<p>その後、なんだかんだで<a href="https://github.com/u2zv1wx/neut">結局自分で上記のような言語を書くに至った</a>。依存型理論ベースであって、リソース管理のための追加のアノテーションが存在せず、かつメモリ管理が静的であるような言語である。で、実現にあたり、最後の条件をクリアするために考えついた手法がたぶん結構おもしろく、本稿はそれを紹介するものである。</p>
<p>オチを先取りして言うなら、当該の手法は「型を実行する」ような代物になっている。もうすこし正確には、型を、その型をもつ値を複製・破棄するための関数へと変換するようなものとなっている。私はGCもregion-basedな路線もあるいはすべてを手でやる路線もそれぞれに好きなんだけど、それはそれとして、今回の路線はひとつの可能性としてなかなかおもしろいものになったんじゃないかと思う。</p>
<p>あらかじめいくつか断っておく。</p>
<ul>
<li>本稿に安全性の証明のたぐいは一切含まれていない。ズコーッという感じだが、気にせず話を続けると、無論私もそうした証明が添えられていたほうが100倍よいと思ってはいる。とはいえ時間的資源は有限であり、この省除はあれこれを天秤にかけた結果である。あくまでこういう手法が可能っぽいですよ〜という示唆程度のものとして、話半分に受け取ってもらえればと思う。<br />
</li>
<li>動機や背景などについての記述は煩雑を嫌って補遺に回した。つまり本論のほうは手法の要点を最速で書き下すことに焦点をしぼったものとなっている。裏を返して言えば、手法のおもしろみが補遺ありきのものとなっていることを了解されたい。<br />
</li>
<li>本稿はOCamlやHaskellなどの経験があれば一通り読めるようにしたつもりで、読めないようであれば私が悪い。<br />
</li>
</ul>
<p>前置きが長くなった。いいかげん本論に入ることにする。話は所望の性質をもった小さな言語について考えるところから始まる。</p>
<h2 data-toc=":include siblings :depth 2 :ignore (this)" id="toc">目次</h2>
<div class="CONTENTS drawer">
<ol>
<li><a href="#線形性の力を借りる">線形性の力を借りる</a>
<ol>
<li><a href="#変数がちょうど1回だけ使用されるような言語">変数がちょうど1回だけ使用されるような言語</a><br />
</li>
<li><a href="#線形性のもとでのリソース管理">線形性のもとでのリソース管理</a><br />
</li>
<li><a href="#非線形性を密輸入しよう">非線形性を密輸入しよう</a><br />
</li>
</ol></li>
<li><a href="#型を実行する">型を実行する</a>
<ol>
<li><a href="#リソース管理の語彙を対象言語の内部に見る">リソース管理の語彙を対象言語の内部に見る</a><br />
</li>
<li><a href="#型がより具体的にどう変換されるか">型がより具体的にどう変換されるか</a><br />
</li>
<li><a href="#変換された型がどう利用されるか">変換された型がどう利用されるか</a><br />
</li>
<li><a href="#本論のおわりに">本論のおわりに</a><br />
</li>
</ol></li>
<li><a href="#補遺">補遺</a>
<ol>
<li><a href="#自然演繹にすごい勢いで入門する">自然演繹にすごい勢いで入門する</a><br />
</li>
<li><a href="#証明論からくる動機">証明論からくる動機</a><br />
</li>
<li><a href="#局所完全性の計算論的意義">局所完全性の計算論的意義</a><br />
</li>
<li><a href="#複製破棄によるリソース管理を基礎づける">複製・破棄によるリソース管理を基礎づける</a><br />
</li>
<li><a href="#まともな性能を期待できるのか">まともな性能を期待できるのか</a><br />
</li>
<li><a href="#その他のあれこれ">その他のあれこれ</a><br />
</li>
</ol></li>
<li><a href="#跋">跋</a></li>
</ol>
</div>
<h2>線形性の力を借りる</h2>
<h3>変数がちょうど1回だけ使用されるような言語</h3>
<p>フル装備の言語のまえに簡単な部分言語について調べてみるというのは素直な発想だと言ってよいと思う。本稿もその方針でいく。</p>
<p>「簡単な部分言語」と一口に言っても、制限のしかたにはいろいろある。ここでは変数の使われ方に制限を入れる。より具体的には、OCamlとかHaskellのような言語であって、定義された変数がすべてちょうど1回だけ使用されるようなものを考える。こうした変数の使用はしばしば「線形である」といわれる<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
<p>この言語を L<sup>-</sup> とよぶことにしよう。たとえば次の疑似コードは言語 L<sup>-</sup> においてコンパイルを通過するべきものである：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>let y := 1 in</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>add x y</span></code></pre></div>
<p>変数 <code>x</code>, <code>y</code> がどちらも線形に使用されていることに注目してほしい。他方で次の疑似コードはコンパイルエラーとなるべきものである：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>add x x</span></code></pre></div>
<p>というのは、変数 <code>x</code> が <code>add x x</code> において2回使用されているからである。少なすぎてもだめで、たとえば</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>10</span></code></pre></div>
<p>は、 <code>x</code> が1回も使用されていないのでコンパイルエラーとなる。あるいは、 <code>increment</code> という関数がすでにどこかで定義されているとして、次の疑似コードもコンパイルエラーとなるべきものである：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>let y := increment x in</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>add x y</span></code></pre></div>
<p>こちらでも変数 <code>x</code> が <code>increment x</code> と <code>add x y</code> において計2回使用されているのがわかると思う。いわば、 <code>increment x</code> において <code>x</code> はすでに消費されてしまっており、それゆえ <code>add x y</code> の時点ではもう <code>x</code> は利用できない、という具合である。</p>
<p>いちおう一言添えておくと、もちろんすべての変数に線形性を課すなんてのは制限として相当キツい部類のもので、実際の言語にこんな制約があればおよそ現実的なプログラムなど書けたものではない。が、我々はすぐあとでこの制約がどのようにして回避されるかを見る。というわけで表現能力の問題については特に心配はいらない。</p>
<h3>線形性のもとでのリソース管理</h3>
<p>ここでは言語 L<sup>-</sup> の構成要素は変数とλ抽象と関数適用と <code>let</code> のみであるとする。つまり、 <code>[1, 2, 3]</code> のような配列であるとか、あるいは上で見たような <code>100</code> のような整数であるとかは言語に含まれないものとしていったん無視しておく。というのは、これらを言語に追加するにしても、結局λ抽象について以下で述べることが実質的にそのまま機能するからである。ようは話が長くなるだけだからカットする。</p>
<p>このような言語 L<sup>-</sup> において静的なリソース管理をおこなうことを考えてみる。つまりコンパイル時の情報だけでメモリをうまく割り当てることを考えてみる。すると、次のような自明な解決があることがわかる。</p>
<p>まず、メモリを割り当てるのは、λ抽象を処理するタイミングとし、またこのときだけとする。たとえば、</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>let f := λ y. (なんかの計算) in</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>(つづきの計算)</span></code></pre></div>
<p>のようなコードがあったとして、このコードの挙動は、</p>
<ol>
<li><code>λ y. (なんかの計算)</code> を表現するためのメモリ領域を割り当て、<br />
</li>
<li>その領域にλ抽象の情報を書き込み（これは <code>(info-1, ..., info-n)</code> のような組になり、クロージャともよばれる）、<br />
</li>
<li>その領域へのポインタを <code>f</code> に束縛して、<br />
</li>
<li><code>(つづきの計算)</code> を実行する<br />
</li>
</ol>
<p>という具合のものになる。この部分の処理については、言語が線形であろうがなかろうがたいした違いはない。メモリ領域を割り当てないことにはλ抽象の情報をメモリ上で表現できないのだから、当たり前といえば当たり前である。</p>
<p>他方、メモリを解放するのは、関数適用を処理するタイミングとし、またこのときだけとする。たとえば、</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(なんかの計算) in</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>f a</span></code></pre></div>
<p>のようなコードがあったとして、このコードの挙動は、</p>
<ol>
<li><code>(なんかの計算)</code> をおこない、<br />
</li>
<li>関数 <code>f</code> に束縛されているはずのλ抽象の情報 <code>info-1</code>, …, <code>info-n</code> をメモリ領域から取り出し、<br />
</li>
<li>関数 <code>f</code> の外側の <code>(info-1, ..., info-n)</code> を解放し、<br />
</li>
<li>とりだしたλ抽象の情報のもと、 <code>a</code> を引数として目的の関数を呼び出す<br />
</li>
</ol>
<p>という具合のものになる。</p>
<p>上記のように定めたメモリ解放は安全で、かつすべてのリソースを解放するのだが、これは言語の線形性からしたがう。すなわち、まず、線形性によって、λ抽象はすべてちょうど1回だけ使用される。これはもちろん、λ抽象がすべて1回以下使用され、かつ1回以上使用されるということである。1回以下使用（適用）されるのだから、任意のλ抽象に対して施されうる解放は1回以下である。つまり性質「解放したものを繰り返し解放してしまうことがない」が保証される。また、1回以上使用（適用）されるのだから、任意のλ抽象に対して施されうる解放は1回以上である。つまり性質「割り当てたものは必ず解放される」が保証される。</p>
<p>というわけで、言語 L<sup>-</sup> においては上記の解釈によってメモリが安全かつ確実に解放される。静的なメモリ管理が実現できる。つまりは所望の性質がタダで得られる。次節では、このありがたい性質を保ちながら言語 L<sup>-</sup> の表現能力を強めることを考える。つまり線形性に対する迂回路を用意することを目指す。</p>
<h3>非線形性を密輸入しよう</h3>
<p>迂回するには抜け道があればよい。任意の型 <code>A</code> について、次のような定数を言語 L<sup>-</sup> に追加してみる：</p>
<ul>
<li><code>copy_A : A -&gt; A * A</code><br />
</li>
<li><code>discard_A : A -&gt; top</code><br />
</li>
</ul>
<p>ここで <code>A * A</code> は2個の <code>A</code> 型の値からなるペアの型であり、また <code>top</code> というのはいわゆるunit型である。少し考えてみれば、これらがあれば変数の数についての制約は迂回できることがわかる。たとえば次のような違法なコードをとってみる：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>let x := 1 in</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>add x (add x x)</span></code></pre></div>
<p>上記のコードは、上の定数を用いて、計算結果を保ちながら次のように書き換えてやることができる：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>let x := 1 in</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>let (x1, tmp) := copy_int x in</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>let (x2, x3) := copy_int tmp in</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>let (add1, add2) := copy_(int-&gt;int-&gt;int) add in</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>add1 x1 (add2 x2 x3)</span></code></pre></div>
<p>そしてこのコードは言語 L<sup>-</sup> のものとして合法である。あるいは</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>10</span></code></pre></div>
<p>という違法なコードについても同様で、こちらは</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>let x := 100 in</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>let () := discard_int x in</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>10</span></code></pre></div>
<p>とすれば済む。どちらの例においても、 <code>copy_int</code> および <code>discard_int</code> によって変数の使用が線形になるよううまく帳尻が合わせられていることに注目されたい。一般に、 <code>A</code> 型の変数 <code>x</code> がn回使用されているとして、</p>
<ul>
<li>n &lt; 1ならば <code>discard_A</code> を用いることで <code>x</code> の使用を線形にすることができる。<br />
</li>
<li>n = 1ならば <code>x</code> の使用はすでに線形である。<br />
</li>
<li>n &gt; 1ならば <code>copy_A</code> を用いることで <code>x</code> の使用を線形にすることができる。</li>
</ul>
<p>それゆえ、線型性によって損なわれていた表現能力はこれらの定数によってとりもどされる。そして、ベースの言語には触れていないのだから、リソースについて奇妙な挙動を示しているのはこれらの定数だけである。というわけで、あとはこれらの定数の中身が具体的にどのようなものになるべきであるかを考えてやればよい<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<h2>型を実行する</h2>
<p>冒頭で先取りして述べた通り、リソース管理のための情報はすでに型のうちにある。本節では、まず型をリソース管理に利用するにあたってのアイデアを示し、次にそのアイデアのもとでより具体的にさまざまな型がどのように上記の <code>copy_A</code> / <code>discard_A</code> を実現するかを見て、最後に型の変換結果がどのように利用されるかを見る。</p>
<h3>リソース管理の語彙を対象言語の内部に見る</h3>
<p>コアとなるアイデアを例で示す。いま、 <code class="verbatim">e</code> という <code class="verbatim">A * B</code> 型のtermがあるとする。このときわれわれは、 <code class="verbatim">e</code> が具体的にどのような内部構造をもっているかを知ることなく、その型情報のみによって、 <code class="verbatim">e</code> を次のように展開することができる：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>let (x, y) := e in (x, y)</span></code></pre></div>
<p>こうした展開はしばしばη展開とよばれるもので、 <code class="verbatim">e</code> にあたるtermが副作用をもたないかぎりにおいて、termの意味を保つ：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>   let (x, y) := (&quot;foo&quot;, (3, true)) in (x, y)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>~&gt; (&quot;foo&quot;, (3, true))</span></code></pre></div>
<p>さて、ポイントは、 <code class="verbatim">e</code> がどんなものであるかによらず、型の情報だけからこの展開をおこなうことができるという点である。これはすなわち、η展開の操作をひとつの関数として書きうるということでもある。つまり次のような関数を <code class="verbatim">A * B</code> に対応するη展開としてとることができる：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  (x, y)</span></code></pre></div>
<p>この関数のなにが嬉しいかって、 <code>e</code> の中身であるところの <code>x</code> および <code>y</code> が変数として参照可能になるところ、つまり <code>e</code> の中身をたどれるようになるところである。いま、このη展開を参考に、型に対してその型をもつtermの中身をたどる関数を対応づけるような変換が仮に定義できるとして、それを <code>Expand(_)</code> と書くことにすると、 <code>Expand(A * B)</code> は、</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  let x&#39; := Expand(A) x in</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  let y&#39; := Expand(B) y in</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  (x&#39;, y&#39;)</span></code></pre></div>
<p>のようになるだろう。他の型に対してもこの <code>Expand(_)</code> を具体的に定めてゆけばtermを再帰的にたどれそうである。</p>
<p>もちろん、 <code>Expand(_)</code> が定義できたとしても、それだけではη展開をterm全体にいわば伝播させることが可能になっただけで、リソースの複製・破棄についての議論はまだ絡んでこない。だがそれらは実は既にほとんど解決ずみである。実際たとえば、すべての型に対して複製関数を対応付けるような変換が仮に定義できるとして、それを <code>Copy(_)</code> と書くとき、 <code>Copy(A * B)</code> は</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  let (x1, x2) := Copy(A) x in</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  let (y1, y2) := Copy(B) y in</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  ((x1, y1), (x2, y2))</span></code></pre></div>
<p>のように定めてやれる。これはたしかに <code>A * B -&gt; (A * B) * (A * B)</code> という型をもっている。あるいはまた、すべての型に対して破棄関数を対応づけるような変換が定義できるとして、それを <code>Discard(_)</code> と書くとき、 <code>Discard(A * B)</code> は、</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>λ z.</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  let (x, y) := z in</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  let () := Discard(A) x in</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  let () := Discard(B) y in</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  ()</span></code></pre></div>
<p>としてやればよい。これもたしかに <code>A * B -&gt; top</code> という型をもっている。</p>
<p>ようするに、 <code>copy_A</code> および <code>discard_A</code> は、展開を関数として再帰的に表現したものを「n乗」へと拡張することで実現できそうに見える、というのがコアのアイデアである。型に対してこのような計算論的解釈を与えられるのではないか、という話である。そしてこのように定数を定義できるのであれば、型 <code>A</code> を定数のペア <code>(copy_A, discard_A)</code> へと変換してやれば、対象言語のほうでこのペアから必要なほうを適宜とりだして使用することで前節で見たような帳尻合わせが可能になるのではないか、という話である。そしてそれを実装しましたよ（証明はないけど！）、というのが冒頭に示したリポジトリである。</p>
<p>なお実際には、型 <code>A</code> は、 <code>copy_A</code> と <code>discard_A</code> のペアではなく、次のような2引数関数 <code>exp_A</code> へと変換されることになる：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>λ flag z.</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  if flag</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  then discard_A z</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  else copy_A z</span></code></pre></div>
<p>この <code>exp_A</code> は次のように使用される：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>-- x : Aをdiscardしたいとき</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>let () := exp_A true x in</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>-- x : Aをcopyしたいとき</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>let (x1, x2) := exp_A false x in</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>(...)</span></code></pre></div>
<p>これは表現能力云々の話ではなく、純粋に実装上の最適化である。これによって、型は（ペアではなく）閉じた静的な関数へと変換されることになる。そして閉じた関数はLLVMのレベルではただの関数ポインタとして、つまり普通の即値と同じように複製・破棄できるから、結局、型の変換結果はふつうの即値と同じように複製・破棄できるということになる。ペアで実装していたならば発生していたであろう面倒なallocation/freeの処理をパスすることができ、かつ実行効率の向上も期待できるという具合であり、それゆえ実装ではこちらの方針をとることにした。</p>
<h3>型がより具体的にどう変換されるか</h3>
<p>ここでは複製・破棄の関数がより具体的にいろいろな型に対してどのように定められるかを見てみる。</p>
<h4>即値</h4>
<p><code>int</code> のような、即値の型について。これについては次のようにして <code>copy</code> と <code>discard</code> を定めてやればよい：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>let copy_int :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  λ x. (x, x)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>let discard_int :=</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  λ x. ()</span></code></pre></div>
<p><code>copy_int</code>, <code>discard_int</code> が受けとる引数は即値であり、それゆえ特にメモリにふれることなく複製・破棄できる。ゆえに非線形に複製・破棄してやればよい。これらの関数におけるメモリにかかわる操作は、 <code>(x, x)</code> のための領域の確保だけである。</p>
<h4>配列</h4>
<p><code>int[3]</code> のような、配列の型について（配列の中身は即値であるとしておく）。これについては次のようにして <code>copy</code> と <code>discard</code> を定めてやればよい：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>let copy_int_3 :=</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  λ x.</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    let [a, b, c] := x in</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    ([a, b, c], [a, b, c])</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>let discard_int_3 :=</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  λ x.</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    let [a, b, c] := x in</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    ()</span></code></pre></div>
<p>つまり、まず <code>x</code> から中身をとりだしたうえで、その中身をつかって新たな配列をつくればよい。ここで、</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>let [a, b, c] := x in (...)</span></code></pre></div>
<p>においては、</p>
<ol>
<li><code>x</code> のそれぞれの要素を <code>a</code>, <code>b</code>, <code>c</code> に束縛し、<br />
</li>
<li>配列 <code>x</code> をfreeする<br />
</li>
</ol>
<p>という挙動が想定されている。というわけで、たとえばcopyのほうの挙動は、</p>
<ol>
<li><code>x</code> のそれぞれの要素が <code>a</code>, <code>b</code>, <code>c</code> に束縛される<br />
</li>
<li><code>x</code> が解放される<br />
</li>
<li><code>[a, b, c]</code> のためのメモリ領域をわりあてる (1回目)<br />
</li>
<li><code>[a, b, c]</code> を新たに構成してメモリ領域に書き込む (1回目)<br />
</li>
<li><code>[a, b, c]</code> のためのメモリ領域をわりあてる (2回目)<br />
</li>
<li><code>[a, b, c]</code> を新たに構成してメモリ領域に書き込む (2回目)<br />
</li>
<li><code>([a, b, c], [a, b, c])</code> のためのメモリ領域をわりあてる<br />
</li>
<li><code>([a, b, c], [a, b, c])</code> をメモリ領域に書き込む<br />
</li>
</ol>
<p>といった具合になる。 <code>a</code>, <code>b</code>, <code>c</code> が即値なのでタダでコピーできていることに注意。あるいはまた、discardのほうの挙動は、</p>
<ol>
<li><code>x</code> のそれぞれの要素が <code>a</code>, <code>b</code>, <code>c</code> に束縛される<br />
</li>
<li><code>x</code> が解放される<br />
</li>
</ol>
<p>という具合になる。 <code>a</code>, <code>b</code>, <code>c</code> が即値なのでタダで破棄できていることに注意。</p>
<h4>型の型</h4>
<p><code>A : Type</code> と書くときの <code>Type</code> もまた型であり、それゆえ変換されるべきものである。が、上でみたように、 <code>A : Type</code> のとき、 <code>A</code> は即値と同様に処理できるのであった。というわけで、</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>let copy_type :=</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  λ x. (x, x)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>let discard_type :=</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  λ x. ()</span></code></pre></div>
<p>として終了である。</p>
<h4>関数の型</h4>
<p><code>int -&gt; bool</code> のような、関数の型の変換について。これはやや複雑なので、大意をつかみたいだけであれば読み飛ばしてもらっても構わないかもしれない。なんにせよ、この部分の説明にはまず（型ではなく）λ抽象がどのように変換されるのかについてふれる必要がある。次のようなコードを考えてみる：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>let f :=</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  let b := true in</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  let y := 10 in</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  λ x. x + (as-int b) + y in</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>(...)</span></code></pre></div>
<p>なお、 <code>as-int</code> は、（なんでもよいが、たとえば） <code>true</code> を <code>1</code> に、 <code>false</code> を <code>0</code> にそれぞれうつすような関数であるとする。</p>
<p>さて上記のコードには、 <code>λ x. x + (as-int b) + y</code> という、自由変数として <code>b : bool</code> および <code>y : int</code> をもつλ抽象が含まれている。こうしたλ抽象は、通常のプログラミング言語においては、ふつう</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>((b, y),</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  λ (x, env).</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    let (b, y) := env in</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    x + (as-int b) + y)</span></code></pre></div>
<p>というペアへと、つまり、</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>({自由変数のあつまり},</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a> λ (もとの引数, env).</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>   let (自由変数だったものたちの名前) := env in</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>   {もとのコード})</span></code></pre></div>
<p>というペアへと変換される（クロージャ変換）。さて、今回の体系では、ここの処理を次のように拡張する。すなわちλ抽象を次のような3要素のtupleへと変換する：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(bool * int,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a> (b, y),</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  λ (x, env).</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    let (b, y) := env in</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    x + (as-int b) + y)</span></code></pre></div>
<p>つまり自由変数についての型の情報を添える<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。ここまでくればもうクロージャの複製・破棄の方法はほとんど明らかである。実際、3つの要素のそれぞれの複製・破棄について、</p>
<ul>
<li><code>bool * int</code> の型は <code>Type</code> であるので、これは即値として複製・破棄ができる。<br />
</li>
<li><code>(b, y)</code> については、第1成分の <code>bool * int</code> を利用すれば複製・破棄ができる。<br />
</li>
<li>関数部分については、これは閉じた関数なので普通の関数ポインタに落とせて、ゆえに即値として複製・破棄ができる。<br />
</li>
</ul>
<p>こうしてクロージャの複製・破棄が実現される<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p>
<p>型のほうの話に戻れば、結局、 <code>int -&gt; bool</code> のような関数の型の <code>copy</code> / <code>discard</code> は、 <code>int</code> とか <code>bool</code> とかによらず</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>let copy_closure :=</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  λ cls.</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    let (env_type, env, func) := cls in</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    let (env1, env2) := env_type false env in</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    ((env_type, env1, func), (env_type, env2, func))</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>let discard_closure :=</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  λ cls.</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    let (env_type, env, func) := cls in</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    let () := env_type true env in</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    ()</span></code></pre></div>
<p>となる。なおここで、</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>let (x1, ..., xn) := x in (...)</span></code></pre></div>
<p>においては、</p>
<ol>
<li><code>x</code> のそれぞれの要素を <code>x1</code>, …, <code>xn</code> に束縛し、<br />
</li>
<li>tuple <code>x</code> をfreeする<br />
</li>
</ol>
<p>という挙動が想定されている。</p>
<h3>変換された型がどう利用されるか</h3>
<p>最後に、上記のように型が変換できたとして、このときユーザの書いた関数のなかの変数がどのように線形化されるのかを見てみる。たとえば次のような関数があるとする：</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>let to-pair :=</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  λ (A : Type) (x : A). (x, x)</span></code></pre></div>
<p>この <code>to-pair</code> という関数は次のように使用されることを意図したものである：</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>to-pair int         3             # ~&gt; (3, 3)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>to-pair string      &quot;hello&quot;       # ~&gt; (&quot;hello&quot;, &quot;hello&quot;)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>to-pair (bool * top) (false, unit) # ~&gt; ((false, unit), (false, unit))</span></code></pre></div>
<p>つまり <code>to-pair</code> は多相的な関数であり、受け取った引数をペアにして返すようなものである（ちなみに <code>int</code> とか <code>string</code> とかの部分は実際には推論で省略できる）。</p>
<p>さて、すぐに見てわかるように、上記 <code>to-pair</code> の定義においては変数 <code>x</code> が2回、つまり線形でない仕方で使用されている。この非線形な <code>x</code> は、型 <code>A</code> の変換結果を用いて、次のように線形化される：</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>let to-pair :=</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  λ A x.</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    let (x1, x2) := A false x in</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    (x1, x2)</span></code></pre></div>
<p>つまり、 <code>to-pair</code> は、たしかにさまざまなサイズをもった値を引数 <code>x</code> の位置に受け取るのだが、それに付随する型 <code>A</code> のほうに <code>x</code> を複製するにあたって必要な情報がつねに入ってくるので、 <code>to-pair</code> は <code>x</code> がどんなものであれ複製することができる。discardについても同様で、このような型情報があればうまくいきそうであることがみてとれると思う。</p>
<h3>本論のおわりに</h3>
<p>以上で本論は終わり。型が実行され、静的なリソース管理が実現された。多分にスケッチ的ではあるが。</p>
<p>ここまで読んでもらえたなら、実装にあたって依存型を選ぶことになった理由もなんとなく察してもらえるのではないかと思う。つまり、型がふつうのtermと同じように出現してくれるので、たんに実装がラクなのである。</p>
<p>そういえば、依存型理論のうれしさを紹介するにあたって私が知っている記事ってほとんど全部くらいの勢いで長さつき配列の例を示しているんだけど（配列の型に長さの情報を付与すれば安全に配列の要素にアクセスできるよ、みたいなやつ）、私は依存型理論のうれしさって、むしろ言語の見通しがよくなるところ、一貫性が高まるところにあるんじゃねえかなあと思っていたりする。ベースの論理体系が依存型になっていると、型についての抽象もふつうの関数もどちらもただのλに落ちてくれるわけで、まあわかりやすい。型の定義のために特別な構文が必要になったりもしない。</p>
<p>というか依存型理論ってよくつらいつらい言われてるけど別にそうでもないと思うんだよな。型推論が決定不能になるよ～ってのも、そりゃ理論のレベルではそうだろうけど、普通にプログラムを書くぶんにはよっぽど変なことでもしないかぎり (System F を派手に逸脱するようなものを書かないかぎり) すげえ普通に推論できるし。そしてだいたいのプログラムってSystem Fの枠内でわりとハッピーに書けるし。推論がめっちゃ遅くなるわけでもないし。まあいいか。</p>
<p>ついでにここでひとつ断っておこう。私はこの型を関数に変換する手法はいちおう新しいものだと思って本稿を書いている。が、往々にして世の中には似たようなことを考えているえらい先駆者がいるものである。同じようなことを書いている人が既にいたなら、そのとき本稿は先人にささげるひとつの注釈であるだろう。</p>
<p>以下は補遺である。こちらを読むと、たぶん、本論がセオリーを知ったあとの格ゲーのようにおもしろくなる。ぜひどうぞ。</p>
<h2>補遺</h2>
<h3>自然演繹にすごい勢いで入門する</h3>
<p>最初は省略することも考えたのだけど、やはり説明上どうにも外せなかった。というわけで自然演繹の入門（超特急）を添える。よりちゃんとした入門記事としては、たとえば<a href="https://www.cs.cmu.edu/~fp/courses/15317-f09/schedule.html">Pfenningの講義資料</a>がよいのではないかと思う。タダで読める。ありがてえ。</p>
<h4>命題論理ことはじめ</h4>
<p>まず互いに区別のつく記号のあつまりをひとつ固定して、この集合の要素を命題変数とよぶことにする。命題変数は自然数と同じ数だけあるとする。そのうえで、命題を次のように定める。</p>
<ol>
<li><span class="math inline">\( \alpha \)</span> が命題変数であるならば、 <span class="math inline">\( \alpha \)</span> は命題である。<br />
</li>
<li><span class="math inline">\( A, B \)</span> が命題であるならば、 <span class="math inline">\( A \to B \)</span> は命題である。<br />
</li>
<li>以上によって命題となるものだけが命題である。<br />
</li>
</ol>
<p>たとえば <span class="math inline">\( P, Q, R \)</span> が命題変数であるとき、 <span class="math inline">\( P \)</span>, <span class="math inline">\( P \to Q \)</span> などは命題であるし、 <span class="math inline">\( P \to (Q \to R) \)</span>, <span class="math inline">\( (P \to P) \to R \)</span> などもまた命題である。</p>
<p>あるいはもしかすると、ここで「<span class="math inline">\( P \to (Q \to R) \)</span>の "<span class="math inline">\( ( \)</span>" と "<span class="math inline">\( ) \)</span>" ってなんだよ」と思う向きがあるかもしれない。そんなに気にしなくてもよいところではあるが、いちおうこの疑問に答えておく。これらのカッコは、たんに <span class="math inline">\( P \to Q \to R \)</span> と書いただけでは、</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    →</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  →   R</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>P   Q</span></code></pre></div>
<p>なのか、それとも</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  →</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>P   →</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  Q   R</span></code></pre></div>
<p>なのかの区別がつかないので、そこを明示するためのメタな記号である。木構造っていう二次元的なものを文章っていう一次元的な環境で表現するにあたっての道具であって、最初から上記のような木構造を毎回書くと決めていればこのカッコは不要になる。でもそれだといちいち場所をとってだるい。なのでカッコを利用して書いてしまいましょうね、という話。整理すると、</p>
<ol>
<li>「<span class="math inline">\( A \to B \)</span> は命題である」と書いてあるときの「<span class="math inline">\( A \to B \)</span>」は上記のような木構造である<br />
</li>
<li>でも木構造をいちいち展開して書くのはだるい<br />
</li>
<li>ところで文章のほうでもカッコをつかえば木構造をうまく表現できる<br />
</li>
<li>ならカッコつかって書けばよくね<br />
</li>
</ol>
<p>という具合である。カッコを利用しているのはあくまで表現上の都合で、そこで表現されているものは木構造である。</p>
<p>あともうひとつ、最後の条件「以上によって命題となるものだけが命題である」がすこし奇妙に見えるかもしれない。が、これもたいしたことはなくて、たんに、たとえば「じゃあ <span class="math inline">\( P \uparrow \uparrow \downarrow \downarrow \leftarrow \to \leftarrow \to  Q \)</span> とか <code>墨染の君が袂は雲なれや絶えず涙の雨とのみ降る</code> とかは命題なんですか」と尋ねられたときにきちんとNoと答えられるようにするためのものにすぎない。最後の条件がないと、なにが命題であるかはわかるが、なにが命題でないかはわからないということになってしまう。</p>
<p>命題については終わり。こんどは「準文脈」を次のように定める。</p>
<ol>
<li><span class="math inline">\( \cdot \)</span> は準文脈である。<br />
</li>
<li><span class="math inline">\( \Gamma \)</span> が準文脈であり、かつ、 <span class="math inline">\( A \)</span> が命題であるとき、<span class="math inline">\( \Gamma, A \)</span> は準文脈である。<br />
</li>
<li>以上によって準文脈となるものだけが準文脈である。<br />
</li>
</ol>
<p>ようするに準文脈とは命題の列である。 <span class="math inline">\( \cdot, A, B, C \)</span> みたいなやつ。あるいは同じことだが、露骨に書けば、</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>      ,</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>     / \</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    ,   C</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  ,   B</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>.   A</span></code></pre></div>
<p>みたいなやつである。命題の場合とちがってカッコの出番がないのは、なんでもよいが、たとえば</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    ,</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  ,   C</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>A   ,</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>   / \</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  .   B</span></code></pre></div>
<p>のような木構造が準文脈の定義からしてそもそも存在せず、それゆえ区別の必要がないことによる。 <span class="math inline">\( \cdot, A, B, C \)</span> を準文脈として書けばそれで木構造がただひとつに決まることによる。</p>
<p><span class="math inline">\( \cdot \)</span> を空の準文脈とよぶことにする。上の例からもわかるように、空でない準文脈は <span class="math inline">\( \cdot, A_1, \ldots, A_n \)</span> というかたちをしているわけだが、これはふつう冒頭の <span class="math inline">\( \cdot \)</span> を省略して <span class="math inline">\( A_1, \ldots, A_n \)</span> と書かれる。</p>
<p>順序を無視した準文脈を「文脈」と呼ぶことにする。<span class="math inline">\( A, B, C, C \)</span> と <span class="math inline">\( C, B, A, C \)</span> は、準文脈としては異なるが、文脈としては同一である。</p>
<p>上記の準備のもと、「判断」を次のように定める。</p>
<ol>
<li><span class="math inline">\( \Gamma \)</span> が文脈であり、かつ <span class="math inline">\( A \)</span> が命題であるとき、記号 <span class="math inline">\( \Gamma \vdash A \)</span> は判断である。<br />
</li>
<li>以上によって判断となるものだけが判断である。<br />
</li>
</ol>
<p>たとえば <span class="math inline">\( A \vdash A \)</span> とか <span class="math inline">\( C \vdash A \to (B \to B) \)</span> とか <span class="math inline">\( \cdot \vdash ((A \to B) \to A) \to A \)</span> とかはすべて判断である。</p>
<p>さて、「判断」とかいうあからさまな名前が与えられているとはいえ、これは今の段階ではまだ特定の記号のパターン、特定の形をした木構造にすぎない。先取りして言うなら、「<span class="math inline">\( \Gamma \vdash A \)</span>」を「<span class="math inline">\( \Gamma \)</span>を仮定したとき <span class="math inline">\( A \)</span> は正しい」と解釈できるようにしたいのだが、まだそうした解釈を可能にするための枠組みがない。</p>
<p>というわけで、次にこの「判断」なるものに対して「この判断は正しい」とか「正しくない」とか言えるようにするための枠組みを定めていく。いわば、われわれは判断の意味について語るための枠組みを定めるのである。</p>
<p>一般に言って、記号の意味を定めるにあたってはおおむねふたつの路線がある。</p>
<ol>
<li>内的な路線。この路線では記号がなにを指示するかを定める。記号「あのリンゴ」に対して、あの机の上に置いてある赤い物体を対応づけるような路線である。これはいわば記号の中身に注目する路線である。指示対象（＝意味）が定められていれば、たとえば「あのリンゴ」によって藤原定家が指示されているとき、それは記号の指示対象（＝意味）として正しくないと判定することができる。<br />
</li>
<li>外的な路線。この路線では記号がどう使用されるかを定める。記号「あのリンゴ」に対して、それを聞いた者にあの机の上に置いてある赤い物体に意識を向けさせる、という用法を割り当てるような路線である。これはいわば記号の振る舞いに注目する路線である。用法（＝意味）が定められていれば、たとえば「あのリンゴ」という言明を聞いた者が突然フォックストロットの練習を始めたとき、それは記号の用法（＝意味）として正しくないと判定することができる。</li>
</ol>
<p>判断の意味づけにあたり、ここでとるのは後者の路線である。つまり判断という記号がどのような仕方で使用されうるものであるのかをいくつかの規則によって定めていく。このような、判断の用法を定める規則のことを推論規則とよぶ。</p>
<p>まず推論規則それ自体についての説明が必要だろう。推論規則は一般に次のような形で表現される：</p>
<p><span class="math display">\[
\require{bussproofs}
\begin{prooftree}
  \AxiomC{\( \mathcal{J}_1 \hspace{1em} \ldots \hspace{1em} \mathcal{J}_n \)}
  \RightLabel{\( \mathsf{(name)} \)}
  \UnaryInfC{\( \mathcal{J} \)}
\end{prooftree}
\]</span></p>
<p>横棒の上にくる <span class="math inline">\( \mathcal{J}_i \)</span> が、前提となる判断である（<span class="math inline">\( \mathcal{J} \)</span> は "Judgement" の "J"）。これらの前提がすべてそろっているとき、横棒を書いてその下に結論としての新たな判断 <span class="math inline">\( \mathcal{J} \)</span> を書いてよい、とするのが推論規則であり、<span class="math inline">\( \mathsf{(name)} \)</span> はその規則の名前である。</p>
<p>さて規則を追加していこう。まずは変数についての規則である：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( (\mathsf{var}) \)}
  \UnaryInfC{\( \Gamma, A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>これは前提として必要な判断が0個であるような規則で、それゆえ横棒の上が空白になっている。キブンとしては、「<span class="math inline">\( A \)</span> が仮定されているならば、 <span class="math inline">\( A \)</span> は正しい。 <span class="math inline">\( \Gamma \)</span> を追加で仮定しても同じことである」のように読まれるべきものである。もうすこし正確に言うと、上記の推論規則を認めることによって、「<span class="math inline">\( \vdash \)</span>」がわれわれの「ならば」の類比物として読まれるべきものとなる。</p>
<p>いくつか例を示しておこう。以下はすべて規則 <span class="math inline">\( \mathsf{(var)} \)</span> の正当な適用である：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( B, A \vdash A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, B, C, D \vdash A \)}
\end{prooftree}
\]</span></p>
<p>他方で以下はすべて規則 <span class="math inline">\( \mathsf{(var)} \)</span> の正当でない適用である：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, C \vdash B \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \to A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( \cdot \vdash A \)}
\end{prooftree}
\]</span></p>
<p>さて次の規則にうつる。次は、「<span class="math inline">\( \vdash \)</span>」の意味を命題のほうの「<span class="math inline">\( \to \)</span>」に埋め込むものである。</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma, A \vdash B \)}
  \RightLabel{\( (\to_{\mathsf{i}}) \)}
  \UnaryInfC{\( \Gamma \vdash A \to B \)}
\end{prooftree}
\]</span></p>
<p>これはキブンとしては、「「<span class="math inline">\( \Gamma \)</span> かつ <span class="math inline">\( A \)</span>」 ならば <span class="math inline">\( B \)</span> が成立しているとき、<span class="math inline">\( \Gamma \)</span> ならば 「<span class="math inline">\( A \to B \)</span>」が成立する」と読まれるべきものである。われわれはすぐ直前で規則 <span class="math inline">\( \mathsf{(var)} \)</span> によって、「<span class="math inline">\( \vdash \)</span>」の意味を「ならば」として、あるいは少なくとも「ならば」と読みうるものとして定めたのだった。ひるがえって、こちらの推論規則は、こうした判断のレベルでの「ならば」を、命題のレベルの 「<span class="math inline">\( \to \)</span>」 という記号に落としこむものになっている。</p>
<p>ところで、上記の規則は論理結合子「<span class="math inline">\( \to \)</span>」を含んだ命題を新たに作りだすものになっている。すなわちこの規則は、どういった条件のもとで特定のかたちをした命題を言いうるのかを定めるものであり、こうした推論規則は導入則 (introduction rule) とよばれる。逆に、特定のかたちをした命題からどういったことが言いうるのかを定めるものもあり、こちらの推論規則は除去則 (elimination rule) とよばれる。「<span class="math inline">\( \to \)</span>」の除去則は次のようになる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_{\mathsf{e}}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>これはようは「<span class="math inline">\( \to \)</span>」として表現された「ならば」を使う方法を与えるものである。「<span class="math inline">\( A \)</span> ならば <span class="math inline">\( B \)</span>」と「<span class="math inline">\( A \)</span>」とが分かっているときに「<span class="math inline">\( B \)</span>」を導出してよいとするものであり、特にこれといってびっくりするようなことはないはずである。</p>
<p>推論規則としてはとりあえず以上の3つ、つまり、</p>
<ol>
<li>変数の規則<br />
</li>
<li>「ならば」の導入則<br />
</li>
<li>「ならば」の除去則<br />
</li>
</ol>
<p>をとっておく。望むならANDとかORとかも追加できるが、話が無駄に長くなるので控えておく。</p>
<p>ここまでに定めた推論規則を繰り返し適用することにより、たとえば次のような記号のパターンを生成することができる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( B, B, A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( B, B \vdash A \to A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( B \vdash B \to (A \to A) \)}
  \AxiomC{\( \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( B \vdash B \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( B \vdash A \to A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \cdot \vdash B \to (A \to A) \)}
\end{prooftree}
\]</span></p>
<p>こうして生成される記号のパターンのことを証明図あるいは単に証明とよぶ。</p>
<h4>証明図にある回り道</h4>
<p>ある判断 <span class="math inline">\( \Gamma \vdash A \)</span> を導出するにあたっても、いろいろな証明図がありうる。たとえば <span class="math inline">\( \cdot \vdash A \to A \)</span> の証明について考えてみる。もちろんこれには</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \cdot \vdash A \to A \)}
\end{prooftree}
\]</span></p>
<p>という素直な証明があるが、他方で、次のような冗長な証明もありうる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( A \vdash A \to A \)}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \cdot \vdash A \to A \)}
\end{prooftree}
\]</span></p>
<p>こちらも同じ <span class="math inline">\( \cdot \vdash A \to A \)</span> を証明しているが、にもかかわらず証明図が無駄にデカい。</p>
<p>ここで次のように問うてみよう。すなわち、このデカさはどこに由来しているのだろうか。上記の証明図はなぜ無駄にデカくなっているのだろうか。結論から言えば、それは、上記の証明図が「回り道」を含んでいるからである。ここで言う「回り道」は、具体的には次の部分である：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( A, A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( A \vdash A \to A \)}
  \AxiomC{\( A \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>ここでは論理結合子「<span class="math inline">\( \to \)</span>」が導入され、さらにこれがすぐさま除去されている。しかし導入してすぐに除去するくらいであれば、最初から導入しなければよいのではないか。このような意味において、上記は「回り道」、証明図を余計にデカくするものである。こうした「回り道」は、より一般には、次のような形をしている：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, A \vdash B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>すなわち「回り道」とは、「ある論理結合子を導入して、すぐさまその論理結合子を除去する」ようなパターンである（ここで、 <span class="math inline">\( \mathcal{H}_1, \mathcal{H}_2 \)</span> は「上につづく証明図」をひとつの記号で表現したものである）。こうした「回り道」は簡約基ともよばれる。</p>
<p>ここで、一般的なほうの簡約基を5分ほどグッとにらむと次のようなことがわかる。すなわち、上記のように簡約基を含んだ証明図があるとき、 <span class="math inline">\( \Gamma \vdash B \)</span> の証明であって簡約基をなくしたものを作ることができる。これには次のようにすればよい。まず</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, A \vdash B \)}
\end{prooftree}
\]</span></p>
<p>の部分に注目する。いま、この <span class="math inline">\( \mathcal{H}_1 \)</span> のどこかで <span class="math inline">\( \Gamma, A \vdash B \)</span> の文脈にある <span class="math inline">\( A \)</span> が使用されているとする。このとき、この <span class="math inline">\( A \)</span> の代わりに、</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash A \)}
\end{prooftree}
\]</span></p>
<p>由来の <span class="math inline">\( A \)</span> を用いるようにしてやる。こうすれば <span class="math inline">\( \Gamma, A \vdash B \)</span> のほうの <span class="math inline">\( A \)</span> には出る幕がなくなる。これはすなわち、 <span class="math inline">\( \Gamma, A \vdash B \)</span> の文脈の中にある <span class="math inline">\( A \)</span> がなくとも <span class="math inline">\( B \)</span> が証明できるということである。すなわち、<span class="math inline">\( \mathcal{H&#39;}_1 \)</span> を、 <span class="math inline">\( \mathcal{H}_1 \)</span> に対して</p>
<ol>
<li>仮定にあった <span class="math inline">\( A \)</span> の代わりに <span class="math inline">\( \mathcal{H}_2 \)</span> 由来の <span class="math inline">\( A \)</span> を用いるようにする<br />
</li>
<li>仮定の <span class="math inline">\( A \)</span> を消去する</li>
</ol>
<p>という書き換えをおこなって得られる証明図であるとすれば、</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H&#39;}_1 \)}
  \UnaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>が導出可能であるということである。この書き換えは次のようにまとめられる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, A \vdash B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\hspace{3em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( {\mathcal{H&#39;}_1} \)}
  \UnaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>このような、簡約基を打ち消す書き換えのことを簡約とよぶ。証明図を簡約しつづけて簡約の余地のない証明図を得ることを正規化とよぶ。</p>
<h4>証明図を簡約する / プログラムを実行する</h4>
<p>前節では <span class="math inline">\( \mathcal{H} \)</span> という記号で証明木を表わしていた。ここでは前節よりもローカルな仕方で証明木の情報を保持することを考えてみる。つまり、推論規則を適用するたびに、その適用した推論規則のログを残すようにしてみる。そのログを見ればそこまでにどういった推論規則の適用があったのかを判別できるようにするのである。まず、変数の規則をもういちど見てみる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( \Gamma, A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>ここでどのような推論をおこなったのかのログを判断に埋め込みたい。そのためには、たとえば</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( A, A \vdash A \)}
\end{prooftree}
\]</span></p>
<p>という推論において、文脈の <span class="math inline">\( A \)</span> のうちどちらが使用されているのかを区別できていなければならない（でないとその情報が失われてしまう）。そこで、文脈のそれぞれの命題に名前を与えることにする。具体的には次のようにする。まず、自然数と同じ数だけの要素からなる集合をとり、これを変数集合と呼ぶことにする。また変数集合の元のことを変数と呼ぶことにする。そのうえで、準文脈の定義を次のように拡張する。</p>
<ol>
<li><span class="math inline">\( \cdot \)</span> は準文脈である。<br />
</li>
<li><span class="math inline">\( \Gamma \)</span> が準文脈であり、かつ、 <span class="math inline">\( x \)</span> が変数であり、かつ、 <span class="math inline">\( A \)</span> が命題であるとき、記号 <span class="math inline">\( \Gamma, x : A \)</span> は準文脈である。<br />
</li>
<li>以上によって準文脈となるものだけが準文脈である。</li>
</ol>
<p>さらにまた、次のように「証明項」を定義する。これを用いて証明のログを記録していくことになる。</p>
<ol>
<li><span class="math inline">\( x \)</span> が変数であるとき、 <span class="math inline">\( x \)</span> は証明項である。<br />
</li>
<li><span class="math inline">\( x \)</span> が変数で、かつ <span class="math inline">\( e \)</span> が証明項であるとき、 <span class="math inline">\( \lambda x. e \)</span> は証明項である。<br />
</li>
<li><span class="math inline">\( e_1 \)</span>, <span class="math inline">\( e_2 \)</span> が証明項であるとき、 <span class="math inline">\( e_1 \mathbin{@} e_2 \)</span> は証明項である。<br />
</li>
<li>以上によって証明項となるものだけが証明項である。</li>
</ol>
<p>この証明項を用いて、判断の定義を次のように拡張する。</p>
<ol>
<li><span class="math inline">\( \Gamma \)</span> が文脈であり、 <span class="math inline">\( e \)</span> が証明項であり、 <span class="math inline">\( A \)</span> が命題であるとき、記号 <span class="math inline">\( \Gamma \vdash e : A \)</span> は判断である。<br />
</li>
<li>以上によって判断となるものだけが判断である。</li>
</ol>
<p>これで規則 <span class="math inline">\( \mathsf{(var)} \)</span> を拡張するための準備がととのった。先に <span class="math inline">\( A, A \vdash A \)</span> の例がどのように変わるかを示したほうがわかりやすいだろう：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( x : A, y : A \vdash y : A \)}
\end{prooftree}
\]</span></p>
<p>つまり文脈のそれぞれの命題に <span class="math inline">\( x \)</span> や <span class="math inline">\( y \)</span> といった名前が与えられたことによって、どちらの命題が規則 <span class="math inline">\( \mathsf{(var)} \)</span> において使用されたのかの情報を保持できるようになる。推論規則としては、</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\(  \)}
  \RightLabel{\( \mathsf{(var)} \)}
  \UnaryInfC{\( \Gamma, x : A \vdash x : A \)}
\end{prooftree}
\]</span></p>
<p>となる。判断 <span class="math inline">\( \Gamma \vdash e : A \)</span> における証明項 <span class="math inline">\( e \)</span> の部分に、その判断がどのようにして導出されたのかについてのログ情報が入ってくる。</p>
<p>「<span class="math inline">\( \to \)</span>」の導入則にうつろう。こちらは次のように拡張される：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma, x : A \vdash e : B \)}
  \RightLabel{\( (\to_{\mathsf{i}}) \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x. e : A \to B \)}
\end{prooftree}
\]</span></p>
<p>仮定が <span class="math inline">\( \Gamma, x : A \vdash e : B \)</span> となっているのはたんに判断の定義が拡張されたからで、特におどろくべきところはない。また、結論のほうに出てくる証明項が <span class="math inline">\( \lambda x. e \)</span> という「いかにも」な代物になっているが、これはたんに「<span class="math inline">\( \to \)</span>」の導入則を変数 <span class="math inline">\( x \)</span> に注目して適用したということ（＝証明のログ）を記録しているにすぎない。こうした推論規則の拡張はまったくもってオートマティックであり、特に創意工夫が絡んできたりするところではない。</p>
<p>そして最後に「<span class="math inline">\( \to \)</span>」の除去則を見る。こちらは次のように拡張される。</p>
<p><span class="math display">\[
\newcommand{\app}[2]{#1 \mathbin{@} #2}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e_1 : A \to B \)}
  \AxiomC{\( \Gamma \vdash e_2 : A \)}
  \RightLabel{\( (\to_{\mathsf{e}}) \)}
  \BinaryInfC{\( \Gamma \vdash \app{e_1}{e_2} : B \)}
\end{prooftree}
\]</span></p>
<p>こちらもたんに証明項がわりあてられているというだけの話で、特におどろくべきところはない。</p>
<p>さて、ここでさきほどの簡約基に証明項をわりあてることを考えてみる。すると次のような証明図が得られる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, x : A \vdash e_1 : B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x. e_1 :  A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash \app{(\lambda x. e_1)}{e_2} : B \)}
\end{prooftree}
\]</span></p>
<p>なんだかそれっぽい雰囲気が出てきたが、そしらぬ顔で話を続けてみる。簡約基をなくす操作についてもういちど考えてみる。これは結局、<span class="math inline">\( \mathcal{H}_1 \)</span> に出現する <span class="math inline">\( x : A \)</span> の使用を <span class="math inline">\( e_2 : A \)</span> で代替するという操作である。つまり、簡約結果のほうの証明項は、 <span class="math inline">\( e_1 \)</span> の中に出現するすべての <span class="math inline">\( x \)</span> を <span class="math inline">\( e_2 \)</span> で置き換えたものになる。これはすなわち、</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \mathcal{H}_1 \)}
  \UnaryInfC{\( \Gamma, x : A \vdash e_1 : B \)}
  \RightLabel{\( (\to_\mathsf{i}) \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x. e_1 :  A \to B \)}
  \AxiomC{\( \mathcal{H}_2 \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : A \)}
  \RightLabel{\( (\to_\mathsf{e}) \)}
  \BinaryInfC{\( \Gamma \vdash \app{(\lambda x. e_1)}{e_2} : B \)}
\end{prooftree}
\hspace{3em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( {\mathcal{H&#39;}_1} \)}
  \UnaryInfC{\( \Gamma \vdash e_1 \{x := e_2\} : B \)}
\end{prooftree}
\]</span></p>
<p>ということである。ここで <span class="math inline">\( \{x := e_2\} \)</span> は変数 <span class="math inline">\( x \)</span> の出現を証明項 <span class="math inline">\( e_2 \)</span> で置き換えるという代入の操作で、細かな定義は話が長くなるので省略する。 <span class="math inline">\( x + y + x \)</span> を <span class="math inline">\( e_2 + y + e_2 \)</span> に置き換えるような代物で、まあだいたい気合で想像できると思うので、適宜気合で想像しておいてほしい。</p>
<p>そして最後に、上記の簡約における証明項のふるまいについてだけ注目すれば、次のような（見慣れた？）規則が得られる：</p>
<p><span class="math display">\[
  \app{(\lambda x. e_1)}{e_2} \leadsto e_1 \{x := e_2\}
\]</span></p>
<p>というわけで、証明図を調べていた我々は、いつのまにかλ計算に、ひいてはプログラムにたどりついた。ひるがえって、証明項をプログラムであるとみなせば、今度は、判断 <span class="math inline">\( x_1 : A_1, \ldots, x_n : A_n \vdash e : A \)</span> は「自由変数 <span class="math inline">\( x_1 : A_1, \ldots, x_n : A_n \)</span> のもと、プログラム <span class="math inline">\( e \)</span> は <span class="math inline">\( A \)</span> という型をもつ」という型判断として読まれることになる。特に、ついさっきまで命題として解釈されていたものが、今度は型として解釈されることになる。こうして、たとえば証明図における回り道を解消することはプログラムを実行することに対応し、また回り道をどういう順番で解消していくかがプログラムをどういう戦略で実行していくか（名前呼び、値呼びなど）に対応し、などなど、と話が続いていくことになる。</p>
<p>こうした証明とプログラムとの対応関係はしばしばカリーハワード同型対応などとよばれる。「ならば」の分析からスタートして、証明について議論していたはずが、実際には同時にプログラムについての議論も進めていたことになる、という具合である。</p>
<p>証明の言葉をつかえるようになると、見通しもよくなるし啓発的だし、なにより楽しい。たとえば自然演繹のほうの議論を拡張して「〜は正しい」だけでなく「〜は必然的である」という語彙を追加してやって、で、こいつをプログラムのほうにうつすと<a href="https://www.cs.cmu.edu/~fp/papers/popl96.pdf">多段階計算（lispのquasiquoteみたいなやつ）に相当するものが引き出せたりする</a>。</p>
<p>ちなみに上記のような、証明のほうで作った概念（たとえば必然性の様相）のプログラム側の対応物（たとえば多段階計算）をしばしば計算論的解釈という。「必然性（にもいろいろあるが、そのうちのひとつ）の計算論的解釈は多段階計算である」、みたいな。</p>
<h3>証明論からくる動機</h3>
<h4>証明論でやっていこう</h4>
<p>……と、ここまでが普通のカリーハワード同型対応の紹介である。だが本稿ではこの話に続きがある。いや、実際、私はけっこう感動したのだ、初めてカリーハワード同型対応を知ったとき。それで嬉々として、「よし、じゃあ試しに、同型対応をそのまま利用したような、あらゆる計算に証明論的な背景がひかえているような言語を書いてみよう」と思い立っていろいろ考えてみた。</p>
<p>変数はプログラミング言語のほうに簡単にうつせる。ならばの導入則もいい。除去則もよろしい。あれこれの他の論理結合子もノリで追加できる。不動点演算子も追加できて、はいチューリング完全。多相性も自然演繹のほうを命題論理から述語論理のちょっと弱いバージョンに拡張してやることで実現できて、型推論もよくある手法でふつうに実装できて、いいじゃん、いけるじゃん、と勢いづくわけだけど、ここでふと気付く。「……これメモリどうやって管理すんの？」</p>
<p>証明との対応がつきそうな既存の言語を調べてみる。どうやらGCを利用しているようである（OCaml, Haskell, F#, Idris, Coq, Agda, Lean）。なるほど。しかし今現在はカリーハワードに注目しているのであり、ならば証明の言葉でメモリも管理したいというのが人情である。いや人情であるかは知らんが、少なくとも私の感情ではあった。でもそういう言語は見つからなかった。</p>
<p>結局、上にあるような、プログラムを証明と同等のものとみなしうるという謳い文句はたしかに部分的には本当であるのだけど、少なくとも普通のλ計算をベースの言語とするかぎりにおいて、リソースについての議論は同型対応を逸脱するイレギュラーなものとして、実装上の工夫によって解決されるべきものとして処理されているようであった。なかなかうまくいかないものである。</p>
<h4>regionでよくないかしら</h4>
<p>さらにリソースの管理方式について調べていくとregion-basedな路線に出会うことになる。これは型システムにアノテーションを加えることでメモリ管理のための情報をとるという路線である。なるほどクールな路線ではある。メモリ管理も静的になるし、変な仕方でメモリを使用していた場合にはそれをコンパイル時に検出できたりもするし。</p>
<p>けれども私は強欲で、話をもっと証明に寄せたいと思ってしまうのである。直観主義の自然演繹を逸脱するようなアノテーションを利用するのは避けたい。プログラミング言語のほうに「証明論っぽくない」™、実装ありきのものを入れるのではなく、いつもの自然演繹の内部にリソース管理のための語彙を認めたい。「証明について考えていたらプログラムが出てくる」の図式をメモリについても維持したい。だから、現在の関心のもとでは、region-basedな体系をそのまま受け入れることはできない。別な関心のもとでは超便利であるとはいえ。</p>
<p>おそらく、ここでregion推論とよばれる手法についても検討してみるべきだろう。これは普通の型推論の拡張であって、型を推論するのと同時にregionを — メモリ管理のための情報を — 推論するものである。この手法のもと、たとえばStandard MLというOCamlによく似た言語（言語仕様）のコンパイラであって、静的にメモリを割り当てる/解放するようなものが<a href="https://sourceforge.net/projects/mlkit/">開発されていたりする</a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。</p>
<p>これはすなわち、特に追加のアノテーションを書くことなしに、直観主義の範囲で書かれたプログラムに対してそのメモリについての挙動を静的に定めてやれるということである。ならばこれで全部オッケーなのではないか。推論つきのregion-based memory management, これこそが顧客が本当に必要だったものなのではないか。</p>
<p>これに対しての応答は、次のような、型アノテーションが省略されたプログラムについて考えてみるところから始まる：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>λx. (not x, 10)</span></code></pre></div>
<p>上記のλ抽象の型を推論するにあたり、ふつうコンパイラは <code>x</code> の型をいったん不明であるとし、そこに型変数を挿入するだろう。つまり、型変数を <code>?M</code> と書くとして、</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>λ(x : ?M). (not x, 10)</span></code></pre></div>
<p>のようなtermをつくるだろう。そのうえで型推論をおこない、 <code>not : bool -&gt; bool</code> のような情報を利用して、 <code>bool = ?M</code> のような制約がつくられる。そうしてこれが解かれ、 <code>?M = bool</code> という置換が得られる。そしてこれをもとのtermに適用することによって、</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>λ(x : bool). (not x, 10)</span></code></pre></div>
<p>のようなtermがつくられる。それゆえもとのユーザのプログラムはこちらのプログラムの略記であったということになる。ここで注目すべきは、上記のプログラムに対してまさに上記のような仕方で <code>?M</code> という穴が与えられたのは、ひとえにその型推論の定義によるという点である。もし仮に、（なんでもいいが）たとえばこの型推論において変数の使用回数についての情報も取得したいのであれば、コンパイラは</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>λ(x : &lt;?M, ?n&gt;). (not x, 10)</span></code></pre></div>
<p>といった具合のtermを作ることになり、これが解かれて</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>λ(x : &lt;bool, 1&gt;). (not x, 10)</span></code></pre></div>
<p>のようなtermが得られ、それゆえもとのユーザのプログラムは今度はこちらの略記であったということになる。というわけで、ユーザが書いたプログラムがどのような略記であるかは、ひいてはその略記を展開した姿は、型推論に相対的である。</p>
<p>さて、region推論は型推論の一種である。それゆえ、こうした推論をおこなう言語においてユーザが書くプログラムもまた、region推論に沿った略記ということになる。もっと言えば、region推論をおこなう言語において書かれるプログラムは、ちょうど上記の <code>?n</code> のようにして、型だけでなくregionについての省略も含んだものとなる。「本当は具体的にregionについての情報も書けるんだけど省略してある」という具合である。</p>
<p>というわけで、region推論をおこなう言語において直観主義の範囲で閉じているように見えるプログラムを書いてみせたところで、それはつまるところregionについての記述が省略された – けれども推論結果としてそこにある – プログラムだということになる。推論の仕方を変えた時点で、もとのプログラムがどのような略記であるかが変化している。それゆえ結局、region推論をおこなうケースは、最初からregionを型システムにもっている言語についての議論に帰着される。なのでregion推論による路線もまた、（何度も強調しているようにそれ自体はイケているが）現在の関心からして満足のいくものではない。</p>
<h4>動機と位置づけ</h4>
<p>このようにして次のようなワガママな思いが浮かびあがってくる。つまり、ベースの言語をよくある自然演繹のものとして、証明論の言葉でメモリを管理することはできないのだろうか。λ計算に追加のアノテーションを与えることなしに、そもそものもとの言語のなかにリソース管理の情報を見つけだすことでメモリを管理できないだろうか。カリーハワード同型対応はプログラムの簡約についての説明を与えてくれるわけだが、ここにメモリについての説明も見つけられないか。</p>
<p>そしてこうした観点からすると、本稿はこの思いに対して肯定的に答え、さらに具体的にどのようにしてリソース管理を実現するかを示し、また同時にその実装も与えるものとなっている。「それができりゃあ苦労しないよ」と言われそうな与太話の「それ」を実現するようなものになっている。……苦労しなくなるのかどうかは謎だが。</p>
<p>こうしてようやく本稿に動機と位置づけが与えられる。長かった。</p>
<p>ところで、本論で見たように、リソース管理のための情報は実は命題＝型のうちにあるのであり、しかもそれはη展開とかいういかにも証明論めいたものを経由して利用されるのであった。しかしそれにしても、なぜη展開なのだろうか？ どうしてη展開について考えることがリソースについて考えることに絡んでくるのだろうか？ 次節ではこの点についてふれる。</p>
<h3>局所完全性の計算論的意義</h3>
<h4>局所健全性</h4>
<p>いったん証明論のほうに話を引き戻そう<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>。さきほど、証明図における回り道を消去するものとしての簡約をみた。ここについてもうすこし詳しく調べてみる。いま、たとえば「かつ」を論理結合子として目下の体系に組み込みたいとする。<span class="math inline">\( A \)</span> と <span class="math inline">\( B \)</span> との「かつ」を「<span class="math inline">\( A \land B \)</span>」と書くとして、「<span class="math inline">\( \land \)</span>」の導入則と除去則はどうなるべきか。</p>
<p>いや、まあ、導入則と除去則を書き下すことそのものは別にむずかしくない。導入則はたとえば次のようになるだろう：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
\end{prooftree}
\]</span></p>
<p>つまり、<span class="math inline">\( A \land B \)</span> が言えるためには、<span class="math inline">\( A \)</span> と <span class="math inline">\( B \)</span> とがともに言えていなければならない。当たり前といえば当たり前である。除去則も特にむずかしくなくて、選択の余地はあるが、たとえば次のようなものがとれる：</p>
<p><span class="math display">\[
\newcommand{\andlet}[3]{\mathsf{let}\, #1 := #2\, \mathsf{in}\, #3}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}\, e : A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}\, e : B \)}
\end{prooftree}
\]</span></p>
<p>どうでもいいが、ここで <span class="math inline">\( \pi \)</span> は "projection" の "p" の意である。</p>
<p>この論理結合子の簡約は次のようになるだろう：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(e_1, e_2) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
\end{prooftree}
\]</span></p>
<p><span class="math inline">\( \pi_\mathsf{R} \)</span> のほうについても同様であろう：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(e_1, e_2) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
\end{prooftree}
\]</span></p>
<p>ここまでは特に問題ないと思う。</p>
<p>さてここで悪魔に魂を売って、「<span class="math inline">\( \land \)</span>」の導入則を次の2つに置き換えることを考えてみる。</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
\end{prooftree}
\]</span></p>
<p>まあ見るからにヤバい。なんといっても、意味がわからない。実際、このような論理結合子があると、</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\]</span></p>
<p>としてやるだけで、任意の命題 <span class="math inline">\( A \)</span> から任意の命題 <span class="math inline">\( B \)</span> が証明できてしまう。論理体系がぶっ壊れる。このような導入則と除去則の組み合わせを認めるわけにはいかないだろう。</p>
<p>なるほどこのとき「<span class="math inline">\( \land \)</span>」は意味不明である。論理体系をぶっ壊すものである。上の実験からわかるのは、導入則と除去則のあいだにはなんらかの関係が成立していなければならず、そこが崩れていると論理体系をぶっ壊すような、およそ正気ではない、わけのわからない (unsoundな) 論理結合子ができあがってしまうということである。では、ひるがえって、ある論理結合子がまともなものであるためには、導入則と除去則のあいだにいったいどのような関係が成立していないといけないのだろう？</p>
<p>試しに、「論理体系がぶっ壊れるからなんなの？ なんか問題ある？？」と開き直り、そのまま話を続けてみる。通常の「<span class="math inline">\( \land \)</span>」のときと同じように、我々はこの気の狂った論理結合子に対しても簡約を定義しようとするだろう。簡約されるべき「回り道」は、この論理結合子については、導入則2つと除去則2つの組み合わせで次の4つのようになる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(\mathsf{magic}_\mathsf{L}\, e) : A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(\mathsf{magic}_\mathsf{R}\, e) : A \)}
\end{prooftree}
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{R}\, e) : B \)}
\end{prooftree}
\]</span></p>
<p>これらのうち、まず1つ目のものについては次のように簡約が定められよう：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(\mathsf{magic}_\mathsf{L}\, e) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
\end{prooftree}
\]</span></p>
<p>また4つ目のものについても次のようにすればよい：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{R}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{R}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : B \)}
\end{prooftree}
\]</span></p>
<p>問題は2つ目のものと3つ目のものである。2つ目のほうを例にとる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{?} : B \)}
\end{prooftree}
\]</span></p>
<p>われわれは上記の回り道を打ち消すことができない。というのは、回り道を打ち消すためには、除去則の結論（ここでは<span class="math inline">\( B \)</span>）を導入則の前提（ここでは<span class="math inline">\( A \)</span>）だけをつかって示す必要があるわけだが、まさにそれが不可能であるためである。比較対象として、ここで通常の「<span class="math inline">\( \land \)</span>」の簡約を見てみる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_2 : B \)}
  \BinaryInfC{\( \Gamma \vdash (e_1, e_2) : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{L}(e_1, e_2) : A \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e_1 : A \)}
\end{prooftree}
\]</span></p>
<p>ここでは確かに、除去則の結論としての「<span class="math inline">\( A \)</span>」が、導入則の前提としての「<span class="math inline">\( A \)</span>」および「<span class="math inline">\( B \)</span>」だけを用いて証明されていることがわかる（今回はたまたま <span class="math inline">\( A \)</span> しか使用されていないが）。</p>
<p>結局、回り道を打ち消す操作とは、除去則の結論を導入則の前提から証明するという操作である<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>。つまり、簡約が定義できるためには、導入則の結論を除去して得られうるすべての命題が、導入則の前提から証明できなけばならない。言い換えるなら、導入則に対し、除去則が強すぎてはいけない。 — 除去則が強すぎると、導入則の前提でカバーできる範囲を逸脱した命題が得られてしまう。</p>
<p>通常の正気な「<span class="math inline">\( \land \)</span>」の例で言えば、導入則の結論としての <span class="math inline">\( A \land B \)</span> を除去して得られうるすべての命題（つまり <span class="math inline">\( A \)</span> および <span class="math inline">\( B \)</span> ）が、導入則の前提（つまり <span class="math inline">\( A \)</span> および <span class="math inline">\( B \)</span>）から証明できなければならない。そしてこの性質は満足されており、だからこそ「<span class="math inline">\( \land \)</span>」の簡約が可能になっている。</p>
<p>他方、発狂した「<span class="math inline">\( \land \)</span>」の例で言えば、導入則の結論としての <span class="math inline">\( A \land B \)</span> を除去して得られうる命題 <span class="math inline">\( B \)</span> は、 <span class="math inline">\( A \land B \)</span> の導入則の前提が <span class="math inline">\( A \)</span> であるとき、導入則の前提から証明することはできない：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{magic}_\mathsf{L}\, e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \pi_\mathsf{R}(\mathsf{magic}_\mathsf{L}\, e) : B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{?} : B \)}
\end{prooftree}
\]</span></p>
<p>それゆえ簡約が定義できない。導入則に対して除去則が強すぎて、本当であれば言えないはずの <span class="math inline">\( B \)</span> が言えてしまっている。</p>
<p>一般に、簡約の定義できる論理結合子は局所健全性 (local soundness) をもつという。局所健全性をもたないということは、ようするに本来言えないはずのことが言えるということである。あの発狂した論理結合子は、局所健全性をみたしていないがために論理体系をぶっ壊していた、と整理できよう。</p>
<h4>局所完全性</h4>
<p>さて、こう整理すると、今度は局所健全性をひっくり返した性質について考えられるようになる。つまり「除去則が弱すぎない」という性質を考えられるようになる。こちらの性質は局所完全性とよばれる。</p>
<p>局所健全性のときは、けっきょく当該の性質を「簡約が定義できること」という証明図の書き換え可能性についての話に帰着できた。同様に、局所完全性についても、この性質を証明図の書き換え可能性によってとらえることができる。一般にやるとかえってわかりづらそうなので、ここでは <span class="math inline">\( A \land B \)</span> を例にとって説明する。いま、 <span class="math inline">\( e : A \land B \)</span> の証明図が得られているとする。結論から述べれば、このとき、</p>
<ol>
<li><span class="math inline">\( A \land B \)</span> の証明図であって、<br />
</li>
<li>前提として出現するものが <span class="math inline">\( e : A \land B \)</span> だけであり、<br />
</li>
<li>すべての <span class="math inline">\( e : A \land B \)</span> の出現に対してすぐさま除去則が適用されている<br />
</li>
</ol>
<p>ような証明図を構成できるとき、「<span class="math inline">\( \land \)</span>」は局所完全性をもっている、とする。もちろんここは「なんで？」となるところで、さっさとこれがどういう理屈にもとづいているのかを見ていこう。まず、上記の条件に沿った <span class="math inline">\( e : A \land B \)</span> の書き換えとして次のようなものがとれる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \land B \)}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{\( \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{left}\, e : A \)}
  \AxiomC{\(  \vdots \)}
  \UnaryInfC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{right}\, e : B \)}
  \BinaryInfC{\( \Gamma \vdash (\mathsf{left}\, e, \mathsf{right}\, e) : A \land B \)}
\end{prooftree}
\]</span></p>
<p>この展開先の証明図について、確かに、</p>
<ol>
<li>これが <span class="math inline">\( A \land B \)</span> の証明図であること<br />
</li>
<li>前提として出現するのが <span class="math inline">\( e : A \land B \)</span> だけであること<br />
</li>
<li>すべての <span class="math inline">\( e : A \land B \)</span> に対してすぐさま除去則が適用されていること</li>
</ol>
<p>がわかると思う。</p>
<p>いま、仮に除去則が弱すぎたとする。このときは、「すべての <span class="math inline">\( A \land B \)</span> がすぐさま除去される」という条件が存在することにより、<span class="math inline">\( A \land B \)</span> の情報はいくらか欠損した形でしか利用できなくなる。それゆえもとの <span class="math inline">\( A \land B \)</span> の証明を再構成することはできなくなる。たとえば <span class="math inline">\( A \land B \)</span> の除去則から</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash e : A \land B \)}
  \UnaryInfC{\( \Gamma \vdash \mathsf{right}\, e : B \)}
\end{prooftree}
\]</span></p>
<p>を削除したとする。このときは上記の書き換えの <span class="math inline">\( \mathsf{right}\, e : B \)</span> の枝のほうが構成できず、ゆえに「<span class="math inline">\( A \land B \)</span>」を取り戻すことはできない。それゆえこのとき「<span class="math inline">\( \land \)</span>」は局所完全性をもたない（＝除去則が弱すぎる）。</p>
<p>逆に言えば、<span class="math inline">\( A \land B \)</span> を取り戻せているという事実によって、<span class="math inline">\( A \land B \)</span> の除去則が弱すぎないことがわかる。だから上記3点をみたすような展開が可能であることは「<span class="math inline">\( \land \)</span>」の局所完全性の根拠になる。</p>
<h4>局所健全性と時間 / 局所完全性と空間</h4>
<p>さて、一般に言って、プログラムの挙動について考えるとき、展開操作、つまり局所完全性に対応する証明論的な書き換えは、ぶっちゃけ影が薄い。なんならほとんど無視されるくらいの勢いであり、もっぱら簡約のほうにだけ注目されるのが常である。いや、「常である」は言いすぎだろうが、しかしそれくらいの雰囲気はある。特に、λ計算ベースのプログラミング言語の計算の挙動について考えるだけなら、簡約のほうにだけ注目すればそれで終了であり、展開には出る幕がない。</p>
<p>けど、それってわりと不思議であるような気もする。簡約のほうに注目している — 簡約をプログラムとして勝手に便利に利用している — のはヒトの都合で、いわば論理体系から見ればそんなことは知ったこっちゃないわけで、だったら展開が簡約と同じくらいの重要性をもっていてもよいのではないか、という気がしなくもない。なんせ裏返しなんだし<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>。このあたりから、展開にも簡約と同じくらい重要な役割があってもよいのではないか、という発想（妄想）が出てくる。</p>
<p>で、いま、あらためて考えてみると、簡約はまあプログラムの時間的なふるまいをつかさどるものである。でもって、時間の裏返しといえば、それはまあ計算機科学者に尋ねたならばまずは空間なのであり、このあたりから、展開は、局所完全性は、プログラムの空間的なふるまいをつかさどるものなのではないか、というアイデアが浮かんでくる。</p>
<p>そしてあらためて今回やったことをふりかえってみると、これはまさに展開を経由することでメモリの割り当てを、プログラムの空間的なふるまいを制御するものになっている。つまり今回の試行は、次のだいぶ危うげな対比にひとつの支えを与えるものとなっている：</p>
<ul>
<li>局所健全性はプログラムの時間的なふるまいを基礎づけるものである<br />
</li>
<li>局所完全性はプログラムの空間的なふるまいを基礎づけるものである ← NEW!</li>
</ul>
<p>……まあ私としても、ここがかなり妄言めいていることは承知している。「ΩΩΩ&lt;な、なんだってー！？」である。とはいえ本稿の出どころがこのあたりにあったってのもまた事実で、だからひとつの記録として書き残しておくことにした。ブログ感。</p>
<h3>複製・破棄によるリソース管理を基礎づける</h3>
<p>動機や位置づけについての話はここまでとしよう。ここでは本稿の手法のある側面に補足を与える。つまり、複製・破棄による路線にどのような根拠があるのかについて述べておく。</p>
<p>簡約のふるまいを観察してみるところから話は始まる。λ計算における次のようなごく普通の簡約を例にとる：</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>   (λ x. (x, x)) @ &quot;hello&quot;</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>~&gt; (&quot;hello&quot;, &quot;hello&quot;)</span></code></pre></div>
<p>説明のため、この簡約における前後のtermに名前を与えておく：</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>e1 := (λ x. (x, x)) @ &quot;hello&quot;</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>e2 := (&quot;hello&quot;, &quot;hello&quot;)</span></code></pre></div>
<p>このとき上記の簡約はもちろん <code>e1 ~&gt; e2</code> となる。</p>
<p>いま、GCを用いる純粋な言語において、ソースコードに <code>e1</code> というプログラムと <code>e2</code> というプログラムを書いたときの挙動を比較してみる。このとき、もちろん、上記の簡約に対応する計算がおこなわれるか否かにおいて、両者の挙動は異なったものになる。それはそうなのだが、しかし両者の差異はそれだけではない。すなわち次のような空間的な差異がある：</p>
<ul>
<li>ソースコードに <code>e1</code> を書いたときは、文字列 <code>"hello"</code> は一度作成されてしまえば <code>(x, x)</code> において共有される。つまり、 <code>e1</code> を簡約したあとの <code>("hello", "hello")</code> に相当する実行状態においては、第1成分と第2成分とが同一のメモリ領域（文字列 <code>"hello"</code> の先頭）を指示することになる。<br />
</li>
<li>ソースコードに <code>e2</code> を書いたときは、文字列 <code>"hello"</code> は、その2回の出現に沿って素直に2回作成される。</li>
</ul>
<p><code>e1</code> のほうでは文字列 <code>"hello"</code> は1つだけ作成されるのに対し、 <code>e2</code> のほうでは <code>"hello"</code> は2つ作成される。言い換えるなら、こうした実装の言語においては、 <code>e1 ~&gt; e2</code> という簡約の前後どちらのtermをソースコードに書くかによって、プログラムの空間的挙動が異なったものになる。これはすなわち簡約が空間についての計算結果を保存していないということである。</p>
<p>では、β簡約が時間的な計算結果だけでなく空間的な計算結果も保存するよう要求してみるとどうなるか。このときには、 <code>e1</code> のほうにおいても <code>e2</code> と同じ数だけ文字列 <code>"hello"</code> が作成されなければなるまい。つまり2個である。そしてこの2というのはもちろん</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>λ x. (x, x)</span></code></pre></div>
<p>のλ抽象の中に出現している <code>x</code> の数であり、したがって <code>e1</code> の挙動は、call-by-valueで考えるとして、</p>
<ol>
<li>まず引数 <code>"hello"</code> を評価するにあたってこれがメモリ領域に割り当てられ、<br />
</li>
<li>この文字列がλ抽象に渡され、<br />
</li>
<li>λ抽象のほうで変数 <code>x</code> の使用回数nに応じてこの文字列が複製あるいは破棄され、<br />
</li>
<li>そのうえで残りの処理をおこなう、</li>
</ol>
<p>といったものにならざるをえない。そしてこのときはたしかに、 <code>e1</code> を実行したときにも <code>"hello"</code> はちょうど2つ作成されることになる。こうしてリソースの複製・破棄に背景が与えられる。つまり、簡約が時間についての計算結果だけでなく空間についての計算結果も保つよう要求したときに自然と必要となってくるのが複製・破棄の路線である。</p>
<h3>まともな性能を期待できるのか</h3>
<p>ところで、酔いのさめた頭で考えるとして、変数を使用するたびにいちいちコピーが発生するなんてのはまあ狂気の沙汰である。無駄どころの騒ぎではない。CPUの人権侵害である。では、複製・破棄のアプローチは象牙の塔でだけ通用する話であって、およそ非現実的な代物である、というのがオチになるのかというと、これは案外そうでもない。象牙の塔にも隠し扉くらいはある。最適化である。</p>
<p>というわけで以下で可能な最適化について3種類ほど書いていく。ここで一番おもしろいのはたぶん、それぞれの詳細よりもむしろ、これらリソースにかかわる性能云々の議論がすべてλ計算におけるtermの書き方についての議論に帰着されているという点である。既存のλ計算に手を加えることなしにその内部にリソース制御のための語彙をみつけている、ってところにアツさがある。</p>
<p>容易に予想されるとおりベンチとかはないので話半分に聞いてもらえればと思う。</p>
<h4>借用もどき</h4>
<p>1つ目。freeされうるものを引数として受け取ったときは、それを返り値に含めましょう、という話。次のようなコードを考えてみる：</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>let str := &quot;hello&quot; in</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>let _ := print str in</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>let _ := print str in</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>print str</span></code></pre></div>
<p>上記は <code>"hello"</code> と3回出力するコードである。ここで注目するべきは、変数 <code>str</code> が3回使用されていることである。それゆえ上記のコードにおいては <code>"hello"</code> の3つのコピーが作成されることになる。だいぶつらい。</p>
<p>だが、この状況はちょっと考えてやれば回避できる。ポイントは <code>print</code> の型である。素朴にはこの型を <code>string -&gt; top</code> のようなものにしたくなるところだが、そうではなくて、 <code>string -&gt; string * top</code> とするのである。つまり <code>print</code> を、</p>
<ol>
<li>文字列 <code>s</code> を引数として受け取り、<br />
</li>
<li><code>s</code> を出力し、<br />
</li>
<li><code>s</code> と <code>top.unit</code> のペアを返す<br />
</li>
</ol>
<p>という挙動のプリミティヴ関数として定める（このような <code>print</code> は <code>s</code> を2回使用しておきながらその複製をおこなわないというイレギュラーな挙動をもった関数、いわばズルであり、それゆえコンパイラ内部で定義される）。このような <code>print</code> を利用すれば、上記のコードは</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>let str := &quot;hello&quot; in</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>let (str1, _) := print str in</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>let (str2, _) := print str1 in</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>print str2</span></code></pre></div>
<p>あるいは同じことだが、変数名をそろえて</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>let str := &quot;hello&quot; in</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>let (str, _) := print str in</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>let (str, _) := print str in</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>print str</span></code></pre></div>
<p>と書き換えられる。これによって <code>"hello"</code> の出力にともなう複製は回避されることになる。</p>
<p>ちなみに上記のような、「引数として受け取ったものをそのまま返り値に同じ名前で含める」というのはどうやら頻出するパターンであるらしい。というわけで今回実装した言語においてはそれ専用の構文を用意してある。つまり、</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>let _ := print &amp;str in (...)</span></code></pre></div>
<p>などと書くと、これは</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>let (str, _) := print str in (...)</span></code></pre></div>
<p>へとパース時点で書き換えられるようにしてある（実際の構文はS式ベースなので微妙に異なるが、本質的には上記の通りである）。借用もどきとでも言ったところか。あんまり借用とか言ってしまうとC++とかRustとかのやつと言葉が衝突して微妙なのでひかえたほうがよさそうだが。</p>
<p>なんにせよ、これを用いると、たとえば文字列を2回printするような関数は次のように定義されることになる：</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>let print_twice :=</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  λ str.</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;str in</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;str in</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    (str, top.unit)</span></code></pre></div>
<h4>状態とshadowing</h4>
<p>2つ目。いま、われわれの言語において状態の絡んだ計算を表現したいとして、どういった方針をとるのがよいかを考えてみる。もちろんλ計算の力を使って、たとえばstateモナドを用いるという手はある。けれどもここには一つ難点がある。stateモナドにおける <code>get</code> が通常どのように実装されるかを見てみよう：</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>let get :=</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  λ s. (s, s)</span></code></pre></div>
<p>ここで <code>s</code> の場所にくるのは状態である。たとえば <code>string</code> を状態としてもつようなstateモナドであれば、 <code>s</code> としては文字列が渡されることになる。こう見れば問題は明らかだろう。つまり、変数 <code>s</code> が <code>get</code> において非線形に（2回）使用されているため、 <code>get</code> を呼び出すたびに文字列のコピーが発生してしまうのである。状態を利用するたびに、状態がまるっとコピーされてしまう。これはさすがに悲劇である。できれば避けたい。というわけで、別な方法で状態を実現できないかと考えることになる。</p>
<p>そしてそうした「別な方法」は実際に存在する。端的に言って、トップレベルの変数に対して上で見たようなshadowingによる最適化をほどこせば済む。具体例を示すのがよいだろう：</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>-- 状態を保持する変数を定義する</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>let str-state :=</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  &quot;hello&quot; in</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>-- 状態sをうけとり、その状態のもとで計算をおこない、(更新された状態、top.unit)というペアを返す関数を定義する</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>let proc :=</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  λ s.</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    -- テキトーな計算</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;s in</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    let s := concat s &quot;!&quot; -- 現在の状態（文字列）の末尾に &quot;!&quot; を追加する</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>    let _ := print &amp;s in</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    (s, top.unit) in</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>-- トップレベルでさきほどの借用もどきを利用する</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>let _ := proc &amp;str-state in</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>-- 上記は let (str-state, _) := proc str-state と同じもので、だからこの時点でstr-stateは &quot;hello!&quot; になっている</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>-- もう一回利用してみる</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>let _ := proc &amp;str-state in</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>-- この時点でstr-stateは &quot;hello!!&quot; になっている</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>(...)</span></code></pre></div>
<p>という具合である。 <code>get</code> の場合とちがって状態を保持する変数（この場合では <code>str-state</code> ）が線形に使用されているところ、状態を読むことができているところ、状態を書き換えることができている（かのように見える）ところに注目されたい。こうして余計なコピーを引き起こすことなく状態を利用することが可能になる。</p>
<p>なんにせよ、原理的に上記のようにして状態管理が可能であるなら、あとは適当な構文糖衣を用意してやるだけの話である。それゆえ状態にともなうコピー祭りは回避できる。状態管理、くらりんり、君に聞こえるのは僕が知らない声になっていく。</p>
<h4>対応するmalloc/freeの打ち消し</h4>
<p>3つ目。静的にリソース管理が実現されるという点についてあらためて考えてみる。当たり前のことではあるが、このときは、コンパイルが終了した時点で、どこにmalloc/freeが挿入されるか、またmallocにおいて確保するべきメモリ領域のサイズはいくらか、といった情報がすでに得られていることになる。であるならば、コンパイル結果には、たとえば次のような疑似コードに相当するようなLLVMコードが含まれうることになる：</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>a := malloc(SIZE);</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>free(a);</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>b := malloc(SIZE);</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>free(b);</span></code></pre></div>
<p>このとき、 <code>a</code> と <code>b</code> との <code>malloc</code> ではどちらも同サイズのメモリ領域を利用するのだから、不要になった <code>a</code> の領域を <code>b</code> で使い回すことができるはずである。つまり、上記のコードを</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>a := malloc(SIZE);</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>b := a;</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>(...)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>free(b);</span></code></pre></div>
<p>に書き換えられるはずである。で、それは実際に可能で、この最適化処理は今回実装した言語のなかに組み込んである。</p>
<p>これだけだとちょっとそっけないので、一言コメントを添えてみる。ベースの言語がλ計算ベースであることを思い出してもらうと、この言語に対し、コンパイル時点で簡約（インライン展開）をかなりゴリゴリと適用していけることが想像できると思う。でもって、インライン展開をおこなえばおこなうほどに、ひとまとまりのコード片（λ抽象の中身）のサイズは大きくなっていくはずで、ということは上記のような、サイズのそろったmalloc/freeのペアは見つかりやすくなっていく。というわけで、こちらの最適化はインライン展開とも相性のよいものとなっている。</p>
<h4>性能についての総括</h4>
<p>それで、これらの最適化が現実にどれくらいうまく機能するのか、まともな性能を期待できるのかだけど、正直言ってわからない。個人的には、上記のようにやれば線形λ計算で書ける範囲って案外広いんじゃないか、案外いけるんじゃないか、って気がしていたりもするのだが、こんなのはただの想像であって、どんなものによっても支えられておらず、どこにもたどりつかない。実際にフルの言語にしてプロファイルもとれるようにして、などとしてみたいところではあるが、即物的なあらゆるものが足りない。</p>
<p>そういえば、関連する話として、マルチスレッドな挙動を考えたときにどうなるのかも気になるところではある。変数の書き換えを上記のようなshadowingでやるかぎりにおいて、たぶん複数スレッドのあいだで状態を送ったり受け取ったりといったことはできなくなると思うんだけど、それがどれくらいしんどいのか。</p>
<p>Curry-Howard的な路線として、<a href="https://arxiv.org/abs/1802.00961">Gödelの公理などをもちいて複数スレッド間でデータを受け渡したりするような研究</a>もあるみたいで、どうしても証明論的に状態を共有したいのであればこっちの路線を調べていくことになるのかもしれない（Gödelの公理ってのは <span class="math inline">\( (A \to B) \lor (B \to A) \)</span> ってやつ）。しかし当該の論文における簡約はかなり込み入ったものとなっていて、まだそのままではちょっとあつかいづらいように見える。どうしたもんでしょ。現実的には、怪しげな定数を入れてやってそっちにマルチスレッドな挙動のためのズルを詰め込むとか、そういう路線になるのだろうか。よくわからない。</p>
<h3>その他のあれこれ</h3>
<p>落ち穂拾い。やってないことなどについて。</p>
<h4>安全性の話</h4>
<p>まず、記事冒頭にも書いたが、この手法がなんらかの意味において正当、あるいは安全であることの証明はまだない。時間的資源とかのあれこれを天秤にかけた結果である。</p>
<p>安全性についてひとつふれておくべきことがあるなら、Russellのパラドックスにかかわるものだろうか。今回の論理体系は <code>Type : Type</code> を認めており（あるいはまた不動点演算子を含んでおり）、それゆえもちろん矛盾している。つまり任意の型 <code>A</code> に対し、その型をもつような証明項 <code>e</code> が存在する。他方で本稿のリソース管理システムは型/命題ありきのものとなっているのだった。であるならば、この矛盾を利用しておかしな型をつくってやればリソース管理システムを破壊できるのではないか、という疑問がありうる。</p>
<p>が、実際にやってみるとわかるが、これはたんに <code>e</code> の実行が無限ループに陥るだけの話である。 <code>Type : Type</code> を認めているからといって、たとえば突然 <code>"hello" : int</code> のような型判断が通るようになったりはしない。 <code>Type : Type</code> や <code>fix</code> を利用することで任意の命題 <code>A</code> に対してその証明 <code>e : A</code> を構成するとき、この <code>e</code> はなお一定のパターンにしたがっているのであり、いわばこうした体系は秩序をもって矛盾しているのである。……例によって証明はないが。</p>
<p>あ、もちろん無限ループからスタックオーバーフローを経由してセグフォを引き起こすことはできる。Cとかと同じように。</p>
<h4>表示的意味論どこ？</h4>
<p>詳しい人が見ればゼロコンマ2秒で分かる通り、本稿の話は統語論というか証明論にかなりかたよったものであって、表示的意味論の話がまったく含まれていない。実際のところ、型を特定の関数へと変更するというのは結構おもしろい気がしていて、その圏論的意味論からみたふるまいも気になるところではあるのだが、残念なことにいまのところ私は依存型の圏論的意味論をよく知らない。「無敵のfibrationってやつでなんとかしてくださいよ〜」くらいの知識しかない。つまりなにも知らないということである。</p>
<h4>理論的整備がまだまだですねという話</h4>
<p>上の話とも関連するが、まあ理論的整備がぜんぜんである。祈りに近い。正しくブログ記事という感じではあるが。ややテクニカルな話をすると、今回つくったコンパイラがやっていることは、おおむね</p>
<ol>
<li>Calculus of Constructionsとよばれる体系からスタートする（ユーザがソースコードに書くやつはこれ）<br />
</li>
<li>当該の体系をCall-By-Push-Value (CBPV)の依存型バージョンと変換する<br />
</li>
<li>dependent CBPVに対してクロージャ変換をおこなってすべてのλ抽象をclosedにする<br />
</li>
<li>型の計算論的解釈によってリソースの線形化処理をおこなう<br />
</li>
<li>得られた情報を利用しつつ普通のコンパイラと同じようなノリで仮想マシンコードを生成</li>
</ol>
<p>という処理の組み合わせとして理解できるのだが、ここでのそれぞれの変換を具体的に書き下すという作業をおこなっていない。なんなら依存型バージョンのCBPVがぶっこわれていないことをチェックしてすらいない。一般に言って、いけそうな思い付きというのはきちんと定式化してやるとたいていどこかしらバグっているものであり、それは今回の話についてもむろん例外ではあるまい。どっかしらぶっ壊れているかもしれない<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>。</p>
<h4>名前のこと</h4>
<p>どうでもいいが（と書くとき本当にどうでもいいと思っていることがはたしてどれくらいあるのだろうか）、せっかくなので今回書いた言語の名前について一言添えておく。今回の言語の名前は "neut" としてみたわけだが、私は別に、たとえばこの言語はなんらかの意味において中立的なものであるのだぞとか、そうした思いを持っているわけではない。というか「自然演繹大好き～♡」って立場を採用している時点でもう思いっきりopinionatedだし。むしろ、これはたんに実装の内部からきた名前である。</p>
<p>上でも軽くふれたとおり、今回の言語のコンパイルの過程においては、直観主義のλ計算 (Calculus of Constructions) をCall-By-Push-Value (CBPV) という計算体系へと変換する処理が含まれている。CBPVと普通の体系との差異は、前者において型が大きく2種類に分かれるという点に求められる。より具体的には、CPBVにおいては、型が「値の型」と「計算の型」に分かれる。値のほうはふつうpositiveであるとされ、また計算のほうはふつうnegativeであるとされる。つまり言語に極性 (polarity) が入っている。たとえばCBPVにおける「<span class="math inline">\( \to \)</span>」の導入則はつぎのようになる：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma, x : P \vdash e : N \)}
  \UnaryInfC{\( \Gamma \vdash \lambda x.e : P \to N \)}
\end{prooftree}
\]</span></p>
<p>ここで <span class="math inline">\( P \)</span> というのはpositiveな型であり、 <span class="math inline">\( N \)</span> というのはnegativeな型である。λ抽象の引数はつねにpositiveでなければならず、また関数本体はつねにnegativeでなければならない、といった具合で、特に <span class="math inline">\( P \to N \)</span> それ自体はnegativeな型であり、ゆえにたとえばλ抽象をそのまま別のλ抽象に引数として与えることができなくなっていたりする。</p>
<p>線形論理がリソースについて論理をより詳しく分析するものであると言うなら、CBPVは簡約について論理をより詳しく分析するものであると言ってみてもよいかもしれない（ちょっと乱暴かもしれないが）。もうすこし詳しいことについては<a href="https://www.cs.cmu.edu/~fp/courses/15816-f16/lectures/21-cbpv.pdf">このへん</a>をみてもらえればと思う。当該の講義資料は自然演繹についての基本的なことを知っていれば読めるはずである。CBPVを作った/発見した人であるところの<a href="https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf">Levy本人による博士論文</a>はより詳細であるが、いきなりだとなかなか近寄りがたいかもしれない。</p>
<p>なんにせよ、ポイントは、コンパイルの過程においてユーザの入力がpositiveな断片とnegativeな断片とに極化されるというところである。逆に言えば、ユーザが書いたプログラムにはまだ極性が入っておらず、そのかぎりにおいてneutralである。ユーザがソースコードに書くのはneutralな証明項である。というわけで、ちょうどテキストファイルに書かれるのがテキストで、その拡張子が ".txt" となるように、neutral termを書くファイルの拡張子は ".neut" とすることにし、これをそのまま言語の名前として用いることにしてみた。それだけの話でした。</p>
<h2>跋</h2>
<p>対ありでした〜</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>もしかすると、この制限はなんだか突然どこからともなく降ってきた恣意的なものに見えるかもしれない。が、これは実際には直観主義論理を考えるかわりに線形論理で考えてみるという「よくある」分析に沿ったものとなっている。こういう分析について書いてある文献としては照井先生の<a href="http://www.kurims.kyoto-u.ac.jp/~terui/birth.pdf">これ</a>が個人的におすすめ。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>ややテクニカルな注釈を添えておく。線形論理からスタートして直観主義論理の表現能力を得ようと思ったなら、まず考えつくのはexponentialの様相を使うことだろうが、こちらの方針ではうまくメモリを静的に管理することができない（と思う）。というのは、S4の様相と同様の仕方でこのexponentialの様相を入れ、さらにその様相をもつもの（つまり <code>!A</code> という形の型を持つもの）に対してweakening / contractionを認めたとき、当該の論理体系はけっきょく <code>!A</code> という形の型だけが出現するようなフラグメントとして実質的に直観主義論理をそのまま含むことになってしまうからである。最初の「直観主義論理ベースな計算体系のメモリってどうやって管理するの？」の問題に戻ってきてしまう。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>あるいは、ここで次のような疑問を抱くかもしれない。つまり、型のなかに自由変数が含まれていたらどうするのか、という疑問である。結論から言うと、こうした状況には自由変数の概念を拡張することによって対応する。つまり、自由変数の型の中に含まれる自由変数もまた、もとのtermの自由変数として数え入れるのである。たとえば、</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>λ (A : Type). λ (x : A -&gt; int). (x, 100)</span></code></pre></div>
<p>のようなtermがあったとする。このとき、 <code>(x, 100)</code> の自由変数は、普通はたんに <code>x</code> だけであるとされる。が、ここでは、 <code>x</code> の型であるところの <code>A -&gt; int</code> が自由変数として <code>A</code> を含んでいるので、この <code>A</code> もまた自由変数として数え入れられることになる。他方、 <code>A</code> の型であるところの <code>Type</code> には自由変数は含まれないので、けっきょく、 <code>(x, 100)</code> の自由変数は <code>A, x</code> である、となる。このようにすることで、自由変数をコピーするための型の情報がすべてクロージャの第1成分に入ってくることになる。これによってクロージャがうまくコピーできるようになる。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>クロージャ変換のこの3要素への拡張は本質的にはただの存在量化である。親しみ深い存在量化は、 <code>x + 1 = 0</code> のような自由変数をもった主張から始めて、ここから <code>exists (x : Integer). x + 1 = 0</code> のような命題をつくり、いわば変数 <code>x</code> の部分を匿名化するものであった。上でやっているのも同じことで、つまり、もともとクロージャ</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>({自由変数のあつまり},</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a> λ (もとの引数, env).</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   let (自由変数だったものたちの名前) := env in</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>   {もとのコード})</span></code></pre></div>
<p>の型（= 命題）は</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(A1, ..., An) * {...}</span></code></pre></div>
<p>であるわけだが、この第1成分のほう、自由変数の具体的な型のありようを存在量化で匿名化して、</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>Sigma (A : Type). A * {...}</span></code></pre></div>
<p>としているのがここでの変換である。この変換によって、もともと型のほうに入っていた <code>(A1, ..., An)</code> の情報がクロージャの第1成分というterm側に降りてきているところがポイントである。</p>
<p>ところで、このような、クロージャを3成分に拡張する手法は特に新しいものではないらしい。実際、これが本題というわけではないが、<a href="https://github.com/u2zv1wx/neut/issues/1">githubリポジトリのissue</a>で<a href="https://www.ccs.neu.edu/home/amal/papers/closconvcc.pdf">紹介された論文</a>でも同じようなことをやっているとのことであり（まだ読んでいないが）、また簡単に調べてみただけでも、<a href="https://sv.c.titech.ac.jp/minamide/papers/popl96.pdf">1996年時点ですでに似た話がある</a>ように見える。というわけで、いろいろ困ったことになるのは避けたいので、クロージャのこの3要素による変換について、本稿は特にこれといってオリジナリティを主張しない。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>当該のコンパイラにおいては、実際には既存コードをなるべく効率的にコンパイルするべくGCが同時に利用されていたりする。が、これはあくまでひとつの最適化であると理解しておけばよかろう。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>ここでの話は、最後の与太話を除いて<a href="https://www.cs.cmu.edu/~fp/papers/mscs00.pdf">こちらの論文</a>をベースにしたものになっている。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>もうすこし正確には、除去則の結論を、導入則の前提、および除去則の追加の仮定から証明するという操作である。つまり、たとえば <span class="math inline">\( \to \)</span> の除去則では</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{\( \Gamma \vdash A \to B \)}
  \AxiomC{\( \Gamma \vdash A \)}
  \RightLabel{\( (\to_{\mathsf{e}}) \)}
  \BinaryInfC{\( \Gamma \vdash B \)}
\end{prooftree}
\]</span></p>
<p>のように <span class="math inline">\( A \to B \)</span> と <span class="math inline">\( A \)</span> が前提としてとられるが、これでいうところの <span class="math inline">\( A \)</span> が「除去則の追加の仮定」である。「<span class="math inline">\( \land \)</span>」の例ではここが0個になっている。<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>もっと言うと、<a href="https://math.stackexchange.com/questions/1633210/is-there-a-connection-between-local-soundness-and-completeness-in-proof-theory">両者は随伴におけるtriangle identitiesのそれぞれに対応している</a>ようである。<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>そういえば、型に副作用があったらどうするのか、という疑問がありうる。これについては選択肢は少なくとも2つある：</p>
<ol>
<li>言語を純粋にしてそもそも副作用が絡んでいるときには型検査を通過しないようにする<br />
</li>
<li>型検査は通過させて動作を未定義にする</li>
</ol>
<p>前者の路線では、たとえば <code>print</code> の型を <code>string -&gt; io (string * top)</code> などとしておく。こうしてやると、 <code>print</code> を利用しているような型の型は <code>Type</code> ではなく <code>IO Type</code> となってくれるわけで、それゆえ <code>A : IO Type</code> となるとき <code>A</code> は型ではなくなる。というわけでこうした <code>A</code> をたとえば関数の型の内部で <code>A -&gt; int</code> のようにして使用することはできなくなり、秩序が得られる。</p>
<p>後者の路線では「型にわけのわからんものを書いたお前が悪い」の一言ですべてを終了させる。ちなみに今回の言語ではこちらの路線を採用してある。<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></summary>
</entry>
<entry>
    <title>外観チェックのための記事</title>
    <link href="https://vekatze.github.io/post/2020-07-31.html" />
    <id>https://vekatze.github.io/post/2020-07-31.html</id>
    <published>2020-07-31</published>
    <updated>2020-08-09</updated>
    <summary type="html"><![CDATA[<header>
    <h1>外観チェックのための記事</h1>
    
    <span class="metadata">2020-07-31</span>
    
</header>

<p>けっこうよくなってきたように思う（次の画像の表情で）。</p>
<figure>
<img src="../media/atri-confidence.png" width="400" alt="自信ありげな表情の一例 " />
<figcaption aria-hidden="true">自信ありげな表情の一例<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><br />
</figcaption>
</figure>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi vitae eros sollicitudin, tempus tortor nec, vehicula felis. Etiam et elementum nibh. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In hac habitasse platea dictumst. Fusce luctus lectus ut viverra ultrices. Cras sed orci dignissim, vestibulum est efficitur, iaculis quam. Aenean interdum lobortis nisi, in accumsan augue posuere vitae.</p>
<p><code>&lt;p&gt;</code> 要素のなかでの <code>&lt;br&gt;</code> を利用した改行のようすをチェック。<br />
こっちは <code>&lt;br&gt;</code> に続く文章。</p>
<h1>導入：いちばん高いレベルの見出し</h1>
<p>Curabitur ultricies turpis eu placerat maximus. Integer ante neque, volutpat eu tellus nec, accumsan fermentum dolor. In hac habitasse platea dictumst. Aliquam pulvinar vehicula nisl ut imperdiet. Proin congue lobortis ligula a ultricies.</p>
<h2>ひとつ下のレベルの見出し</h2>
<p>Sed nec suscipit augue, in tincidunt mauris. In placerat sem neque, sed malesuada sapien aliquam ut. Mauris at aliquet lectus, ac feugiat ligula. Vivamus consectetur ex nec tempus hendrerit. Nunc ultricies, lectus et vulputate ullamcorper, eros nulla eleifend mauris, sed viverra augue mauris nec ipsum. Quisque volutpat ornare justo, vel vestibulum est condimentum rutrum.</p>
<h2>さらに下のレベルの見出し</h2>
<p>Cras suscipit turpis dictum ornare interdum. Nulla sollicitudin, nibh accumsan fermentum fermentum, erat ligula rhoncus nulla, quis fringilla lectus eros in nulla. Aliquam malesuada, ligula at tristique ornare, lectus nisi viverra eros, ut vestibulum turpis risus ac est. Vivamus iaculis nibh bibendum ex dictum rutrum.</p>
<h2>同じレベルでの見出し</h2>
<p>Cras suscipit turpis dictum ornare interdum. Nulla sollicitudin, nibh accumsan fermentum fermentum, erat ligula rhoncus nulla, quis fringilla lectus eros in nulla. Aliquam malesuada, ligula at tristique ornare, lectus nisi viverra eros, ut vestibulum turpis risus ac est. Vivamus iaculis nibh bibendum ex dictum rutrum.</p>
<p>平行線も試してみよう。</p>
<hr />
<p>このように。けっこういい感じに表示できるね。</p>
<h1>リストのテスト/テストのリスト</h1>
<ul>
<li>Foo<br />
</li>
<li>Bar<br />
</li>
<li>Buzのたぐい。</li>
</ul>
<p>Curabitur ultricies turpis eu placerat maximus. Integer ante neque, volutpat eu tellus nec, accumsan fermentum dolor. In hac habitasse platea dictumst. Aliquam pulvinar vehicula nisl ut imperdiet. Proin congue lobortis ligula a ultricies.</p>
<ol>
<li>Foo<br />
</li>
<li>Bar.<br />
</li>
<li>Buzのたぐい。</li>
</ol>
<h1>引用のテスト</h1>
<p>引用を試す。次はVirginia Woolfの言葉<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>：</p>
<blockquote>
<p>Wait for the dust of reading to settle; for the conflict and the questioning to die down; walk, talk, pull the dead petals from a rose, or fall asleep. Then suddenly without our willing it, for it is thus that Nature undertakes these transitions, the book will return, but differently. It will float to the top of the mind as a whole.</p>
</blockquote>
<p>恐れ多くも翻訳するなら、だいたい次のようになるだろう：</p>
<blockquote>
<p>読書の埃がおさまるのを待つことだ。葛藤や疑問のたぐいが凪いでゆくのを。歩いたり、喋ったり、薔薇から枯れた花弁をひきぬいたり、あるいは眠ったりしてみよ。そうしていると、あるとき突然、われわれがそう望んだからというわけでもなく（というのはこうしたうつろいは自然によって執り行われるものであるからなのだが）、書物が帰ってくる、ただし別様のものとして。書物はこのとき精神のうえにひとつの全体として浮かぶことになる。</p>
</blockquote>
<p>というわけで日本語もちゃんと表示できてる。ソースコードはどうだろうか？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getField ::</span> <span class="dt">Timestamp</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>getField timestamp key format <span class="ot">=</span> field key <span class="op">$</span> \item <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> locale <span class="ot">=</span> defaultTimeLocale</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">&lt;-</span> getTimeWithTimestamp timestamp locale <span class="op">$</span> itemIdentifier item</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> formatTime locale format time</span></code></pre></div>
<p>まあいいんじゃないですか。可読性あるよ。</p>
<h1>あれこれの画像のテスト</h1>
<p>というわけで、画像を表示してみよう。まずは横幅50%での表示。：</p>
<figure>
<img src="../media/internet-is-broken.jpg" style="width:50.0%" alt="インターネットが壊れている様子 " />
<figcaption aria-hidden="true">インターネットが壊れている様子<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a><br />
</figcaption>
</figure>
<p>どうでしょう。ちゃんと表示できてる。いいね。次は横幅100%での表示：</p>
<figure>
<img src="../media/internet-is-broken.jpg" alt="インターネットが壊れている様子 " />
<figcaption aria-hidden="true">インターネットが壊れている様子<br />
</figcaption>
</figure>
<p>拡大すると勢いが増してよい。よほどひどく壊れているのであろう。……サイズが足りていない画像はどう表示するべきだろうか。左揃えだろうか、それとも中央揃えだろうか。自信ありげな表情に登場してもらう：</p>
<figure>
<img src="../media/atri-confidence.png" width="500" alt="自信ありげな表情の一例 " />
<figcaption aria-hidden="true">自信ありげな表情の一例<br />
</figcaption>
</figure>
<p>ふつうに表示できるかな？いける。まあ左揃えか。それにしてもいい表情だ。かくありたいものです。</p>
<p>文中に出てくる <code class="verbatim"># aura -Syu</code> のようなcodeの表示はどうか。素直に等幅にするだけでいいか。……箱に包んでみることにした。</p>
<p>Nam sed tellus consectetur mi sagittis ullamcorper. Duis suscipit enim sed dolor mollis elementum. Duis eu <a href="https://plato.stanford.edu/entries/value-theory/">dignissim</a> libero, eu placerat nibh. Sed id massa vitae dolor tempus scelerisque. Morbi vehicula, dolor sed sodales laoreet, metus magna posuere odio, eu tristique metus elit non ipsum. Cras lorem purus, vehicula ut rutrum eget, pulvinar a ex. Cras pretium ligula eu maximus gravida. Cras a est quam. Fusce bibendum ultricies nibh ac venenatis. Phasellus posuere non neque interdum euismod. Nam bibendum id elit ut posuere. Nulla facilisi. Praesent venenatis neque sed lacus varius, quis rhoncus lectus ultrices. Sed dictum fermentum libero, sit amet pharetra tortor facilisis vel.</p>
<p>条件にありないものはなお事実にもうずたです。いかに大森さんを話春ちょっと忠告へ殖やしなら自己その英語君か授業にというご話ませんたうので、どんな場合は私私も事実いくらその戦争人というのの日から経っでしない。もう当時を学習帰りはもうその譴責だたまでの籠ってみるでには圧迫あるたざるて、実際には充たすないなありた。か規律秋刀魚に待って、大森君ののを通りの何を無論同増減とさてあなた左にお意味がならように初めてご相当を亡びだないから、いよいよもし発展に見ですからかねるた事がしですます。</p>
<h1>MathJax</h1>
<p>あとは何がほしいだろう？mathjaxとか？</p>
<p><span class="math display">\[
\require{bussproofs}
\begin{prooftree}
  \AxiomC{$\Gamma, x : A \vdash e : B $}
  \RightLabel{$ \, \to_{\mathsf{i}} $}
  \UnaryInfC{$\Gamma \vdash \lambda x. e : A \to B $}
\end{prooftree}
\]</span></p>
<p>上のような具合で証明木もふつうに書けてしまう。これはさすがに便利であり。必要なときだけheadに入れる感じでいいか。</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{$\Gamma \vdash e_1 : A \to B $}
  \AxiomC{$\Gamma \vdash e_2 : A $}
  \RightLabel{$  \to_{\mathsf{e}} $}
  \BinaryInfC{$\Gamma \vdash e_1 \mathbin{@} e_2 : B $}
\end{prooftree}
\]</span></p>
<p>reductionを書いてみよう：</p>
<p><span class="math display">\[
\begin{prooftree}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\Gamma, x : A \vdash e_1 : B $}
  \UnaryInfC{$\Gamma \vdash \lambda x. e_1 : A \to B $}
  \AxiomC{$\vdots $}
  \UnaryInfC{$\Gamma \vdash e_2 : A $}
  \BinaryInfC{$\Gamma \vdash (\lambda x. e_1) \mathbin{@} e_2 : B $}
\end{prooftree}
\hspace{1em}
\leadsto
\hspace{1em}
\begin{prooftree}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\Gamma \vdash e_1 \{x := e_2\} : B$}
\end{prooftree}
\]</span></p>
<p>特に変なことをしなくても普通に書けた。いいね。あと、いちど特定箇所でrequireしてしまえば、それ以降は同じパッケージをrequireする必要はないらしい。正気である。というかエラーこっちのほうが追いやすいまであるよな、これ。</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>フロントウイング・枕, 『<a href="https://atri-mdm.com/">ATRI -My Dear Moments-</a>』, ANIPLEX.EXE, 2020.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Virginia Woolf, "<a href="http://gutenberg.net.au/ebooks03/0301251h.html#e26">How Should One Read a Book?</a>", "The Common Reader", Project Gutenberg, 1925.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>A-1 Pictures, 『<a href="https://kaguya.love/1st/">かぐや様は告らせたい 〜天才たちの恋愛頭脳戦〜</a>』, かぐや様は告らせたい製作委員会, 2019, 11話.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></summary>
</entry>

</feed>
